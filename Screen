--[[
# 'Screen' API Documentation:

The Screen API is designed to handle all of the children
of the native terminal object. The native object can be
the computer itself, a monitor, or any other peripheral
that can be wrapped to as a terminal. All Screens are 
capable of performing every term API function and more.

The terminal will have a table called 'pixels' in which 
it stores the information of every pixel on the screen. 
For example, each 'pixel' will have color, text, level, 
and child reference, if applicable, inside its table. 
With this data, screens will be capable of advanced display 
techniques.    

Refer to function documentation for any general
inquiries. 
<>
]]

--[[ENVIRONMENT VARIABLES]]--
VERSION = "5.1.2"

--[[LOCAL VARIABLES ZONE:]]--
local functions = {}

--[[
# Function: 'hook', Documentation:

Use this function to hook into your APIs, interfaces,
or programs that want to be compatible with regular
term API calls as well. 

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<terminal>  | TABLE OBJECT | Your screen object. 
------------+--------------+-------------

> Returns:
@return: 'hook'
@info  : This will return a table in which it can
be used like terminal object, except it can be used
with screens as well.

> Notes:
To properly use a hook, I recommend using the
following example as a guide:

//////////////// Code Block ////////////////
// local function myFunc(screen)          //
//     local terminal = term.current()    //
//                                        //
//     if screen and screen.isScreen then //
//         terminal = screen:hook()       //
//     end                                //
//                                        //
//     terminal.setCursorPos(1, 5)        //
// end                                    //
////////////////////////////////////////////

The above will check for a screen if applicable, and
will then hook your terminal functions if it can. 
If not, the default terminal will be used for output.

For the 'terminal.setCursorPos(1, 5)' example, if no
screen is available the function will work as if it
was just being invoked as term.setCursorPos(1, 5).
However, if a screen is applicable then it will function
as screen:setCursorPos(1, 5) or screen.setCursorPos(screen, 1, 5).

<>
]]

functions.hook = function(screen)
    -- # Checking screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end
    
    -- # Code:
    local hook = {}
    
    if screen["isParent"] then
        hook.clear = function(...)
            screen:clear(arg[1], arg[2])
        end
        hook.clearLine = function(...)
            screen:clearLine(arg[1], arg[2])
        end
        hook.setTextColor = function(...)
            screen:setTextColor(arg[1])
        end
        hook.setTextColour = function(...)
            screen:setTextColour(arg[1])
        end
        hook.getTextColor = function()
            return screen:getTextColor()
        end
        hook.getTextColour = function()
            return screen:getTextColour()
        end
        hook.setBackgroundColor = function(...)
            screen:setBackgroundColor(arg[1])
        end
        hook.setBackgroundColour = function(...)
            screen:setBackgroundColour(arg[1])
        end
        hook.getBackgroundColor = function()
            return screen:getBackgroundColor()
        end
        hook.getBackgroundColour = function()
            return screen:getBackgroundColour()
        end
        hook.setCursorPos = function(...)
            screen:setCursorPos(arg[1], arg[2])
        end
        hook.getCursorPos = function()
            return screen:getCursorPos()
        end
        hook.setCursorBlink = function(...)
            screen:setCursorBlink(arg[1])
        end
        hook.isColor = function()
            return screen:isColor()
        end
        hook.isColour = function()
            return screen:isColour()
        end
        hook.getSize = function()
            return screen:getSize()
        end
        hook.scroll = function(...)
            screen:scroll(arg[1])
        end
        hook.stretch = function(...)
            screen:stretch(arg[1])
        end
        hook.redirect = function(...)
            return screen:redirect(arg[1])
        end
        hook.current = function()
            return screen:current()
        end
        hook.native = function()
            return screen:native()
        end
        hook.write = function(...)
            screen:write(arg[1], arg[2], arg[3])
        end
        hook.blit = function(...)
            screen:blit(arg[1], arg[2], arg[3], arg[4], arg[5])
        end
        hook.changelevel = function(...)
            screen:changelevel(arg[1])
        end
        hook.scanlevel = function(...)
            return screen:scanlevel(arg[1], arg[2])
        end
        hook.convert = function(...)
            return screen:convert(arg[1], arg[2])
        end
        hook.revert = function(...)
            return screen:revert(arg[1], arg[2])
        end
        hook.resize = function(...)
            screen:resize(arg[1], arg[2], arg[3], arg[4], arg[5])
        end
        hook.refresh = function(...)
            screen:refresh(arg[1])
        end
        hook.visible = function(...)
            screen:visible(arg[1])
        end
        hook.debug = function(...)
            screen:debug(arg[1])
        end
        hook.add = function(...)
            screen:add(arg[1], arg[2], arg[3], arg[4], arg[5], arg[6], arg[7], arg[8])
        end
        setmetatable(hook, getmetatable(screen))
    elseif not screen["isParent"] then
        hook.clear = function(...)
            screen["parent"].clear(screen, arg[1], arg[2])
        end
        hook.clearLine = function(...)
            screen["parent"].clearLine(screen, arg[1], arg[2])
        end
        hook.setTextColor = function(...)
            screen["parent"].setTextColor(screen, arg[1])
        end
        hook.setTextColour = function(...)
            screen["parent"].setTextColour(screen, arg[1])
        end
        hook.getTextColor = function()
            return screen["parent"].getTextColor(screen)
        end
        hook.getTextColour = function()
            return screen["parent"].getTextColour(screen)
        end
        hook.setBackgroundColor = function(...)
            screen["parent"].setBackgroundColor(screen, arg[1])
        end
        hook.setBackgroundColour = function(...)
            screen["parent"].setBackgroundColour(screen, arg[1])
        end
        hook.getBackgroundColor = function()
            return screen["parent"].getBackgroundColor(screen)
        end
        hook.getBackgroundColour = function()
            return screen["parent"].getBackgroundColour(screen)
        end
        hook.setCursorPos = function(...)
            screen["parent"].setCursorPos(screen, arg[1], arg[2])
        end
        hook.getCursorPos = function()
            return screen["parent"].getCursorPos(screen)
        end
        hook.setCursorBlink = function(...)
            screen["parent"].setCursorBlink(screen, arg[1])
        end
        hook.isColor = function()
            return screen["parent"].isColor(screen)
        end
        hook.isColour = function()
            return screen["parent"].isColour(screen)
        end
        hook.getSize = function()
            return screen["parent"].getSize(screen)
        end
        hook.scroll = function(...)
            screen["parent"].scroll(screen, arg[1])
        end
        hook.stretch = function(...)
            screen["parent"].stretch(screen, arg[1])
        end
        hook.redirect = function(...)
            return screen["parent"].redirect(screen, arg[1])
        end
        hook.current = function()
            return screen["parent"].current(screen)
        end
        hook.native = function()
            return screen["parent"].native(screen)
        end
        hook.write = function(...)
            screen["parent"].write(screen, arg[1], arg[2], arg[3])
        end
        hook.blit = function(...)
            screen["parent"].blit(screen, arg[1], arg[2], arg[3], arg[4], arg[5])
        end
        hook.changelevel = function(...)
            screen["parent"].changelevel(screen, arg[1])
        end
        hook.scanlevel = function(...)
            return screen["parent"].scanlevel(screen, arg[1], arg[2])
        end
        hook.convert = function(...)
            return screen["parent"].convert(screen, arg[1], arg[2])
        end
        hook.revert = function(...)
            return screen["parent"].revert(screen, arg[1], arg[2])
        end
        hook.resize = function(...)
            screen["parent"].resize(screen, arg[1], arg[2], arg[3], arg[4], arg[5])
        end
        hook.refresh = function(...)
            screen["parent"].refresh(screen, arg[1])
        end
        hook.visible = function(...)
            screen["parent"].visible(screen, arg[1])
        end
        hook.debug = function(...)
            screen["parent"].debug(screen, arg[1])
        end
        hook.add = function(...)
            screen["parent"].add(screen, arg[1], arg[2], arg[3], arg[4], arg[5], arg[6], arg[7], arg[8])
        end
        setmetatable(hook, getmetatable(screen))
    end

    return hook
end

--[[
# Function: 'clear', Documentation:

This function is used to clear the screen on the
specified screen. It will check what pixels need updated.

> Parameters:
<Parameter>   | TYPE           | Information:
--------------+----------------+-------------
<screen>      | TABLE OBJECT   | Your screen object.
<override>    | BOOLEAN/STRING | Whether or not to override level logic. You can pass
              |                | 'override' as a string argument if you would prefer that over 'true'.
<transparent> | BOOLEAN        | Whether or not to update the screen pixels when writing.
--------------+----------------+-------------

> Returns:
@return: <nil>

<>
]]

functions.clear = function(screen, override, transparent)
    -- # Checking screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Checking Local Variables:
    if not override then 
        override = false 
    elseif override == "override" then
        override = true
    end

    if not transparent then
        transparent = false
    elseif transparent == "transparent" then
        transparent = true
    end

    if Debugger.check then
        Debugger.check(override, "override", "boolean")
        Debugger.check(transparent, "transparent", "boolean")
    end

    -- # Declaring Local Variables:
    local rep           = string.rep
    local terminal      = screen:hook()
    local scp, spit     = terminal.setCursorPos, terminal.write
    local width, height = screen.width, screen.height

    -- # Code:
    for y = 1, height do
        scp(1, y)
        spit(rep(" ", width), override, transparent)
    end

    -- # Reset Cursor Position Back to Top Left Corner:
    terminal.setCursorPos(1, 1)
end

--[[
# Function: 'clearLine', Documentation:

This function is used to clear the line the screen is 
currently on. It will check what pixels need updated.

> Parameters:
<Parameter>   | TYPE         | Information:
--------------+--------------+-------------
<screen>      | TABLE OBJECT | Your screen object.
<override>    | BOOLEAN      | Whether or not to override level logic.
<transparent> | BOOLEAN      | Whether or not to update the screen pixels when writing.
<line>        | NUMBER       | Specify which line to clear by providing the <y> level of the screen.
--------------+--------------+-------------

> Returns:
@return: <nil>

<>
]]

functions.clearLine = function(screen, override, transparent, line)
    -- # Checking screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Checking Local Variables:
    if not override then 
        override = false 
    elseif override == "override" then
        override = true 
    end

    if not transparent then 
        transparent = false 
    elseif transparent == "transparent" then
        transparent = true
    end

    if not line then
        line = screen.curY
    end

    if Debugger.check then
        Debugger.check(override, "override", "boolean")
        Debugger.check(transparent, "transparent", "boolean")
        Debugger.check(line, "line", "number")
    end

    -- # Declaring Local Variables:
    local width    = screen.width
    local terminal = screen:hook()
    
    -- # Code:
    terminal.setCursorPos(1, line)
    terminal.write(string.rep(" ", width), override, transparent)
    terminal.setCursorPos(1, line + 1)
end

--[[
# Function: 'setTextColor', Documentation:

This function is used to set a new text color on
the screen. Any updated pixels will receive this
new color.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<color>     | NUMBER       | The color to apply to text.
------------+--------------+-------------

> Returns:
@return: <nil>

<>
]]

functions.setTextColor = function(screen, color)
    -- # Checking screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Checking Variable:
    if type(color) ~= "number" then
        error("['color'] was not defined!", 2)
    end

    -- # Code:
    screen.foreground = color
end

functions.setTextColour = functions.setTextColor

--[[
# Function: 'getTextColor', Documentation:

This function is used to get the current foreground
color of the screen.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
------------+--------------+-------------

> Returns:
@return: <screen foreground color>

<>
]]

functions.getTextColor = function(screen)
    -- # Checking screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end
    
    -- # Code:
    return screen.foreground
end

functions.getTextColour = functions.getTextColor

--[[
# Function: 'setBackgroundColor', Documentation:

This function is used to set a new background 
color on the screen. Any updated pixels will 
receive this new color.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<color>     | NUMBER       | The color to apply to text.
------------+--------------+-------------

> Returns:
@return: <nil>

<>
]]

functions.setBackgroundColor = function(screen, color)
    -- # Checking screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Checking Variable:
    if type(color) ~= "number" then
        error("['color'] was not defined!", 2)
    end

    -- # Code:
    screen.background = color
end

functions.setBackgroundColour = functions.setBackgroundColor

--[[
# Function: 'getBackgroundColor', Documentation:

This function is used to get the current background
color of the screen.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
------------+--------------+-------------

> Returns:
@return: <screen background color>

<>
]]

functions.getBackgroundColor = function(screen)
    -- # Checking screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end
    
    -- # Code:
    return screen.background
end

functions.getBackgroundColour = functions.getBackgroundColor

--[[
# Function: 'setCursorPos', Documentation:

This function is used to set the cursor at the point
given on the screen. 

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<x>         | NUMBER       | The x-coordinate of the cursor.
<y>         | NUMBER       | The y-coordinate of the cursor.
------------+--------------+-------------

> Returns:
@return: <nil>

> Notes:
If a screen starts at (5, 5) on the parent display, 
then a call of parent.setCursorPos(screen, 1, 1)
will set the cursor at (5, 5)

<>
]]

functions.setCursorPos = function(screen, x, y)
    -- # Checking screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end
    if type(x) ~= "number" then error("[x] must be type: number; got "..type(x), 2) end
    if type(y) ~= "number" then error("[y] must be type: number; got "..type(y), 2) end

    -- # Code:
    screen["curX"] = x
    screen["curY"] = y
end

--[[
# Function: 'getCursorPos', Documentation:

This function is used to retrieve the current position
of the cursor on the screen provided. 

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
------------+--------------+-------------

> Returns:
@return: <x>, <y>

> Notes:
Even if the cursor is not on the screen provided,
the previous position of where the cursor was is
stored inside the screen's table, so this function
will just return the last known position of where
the cursor was.

<>
]]

functions.getCursorPos = function(screen)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end
    
    -- # Code:
    return screen.curX, screen.curY
end

--[[
# Function: 'getSize', Documentation:

This function is used to obtain the width and height
of the screen given.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
------------+--------------+-------------

> Returns:
@return: <width>, <height>

<>
]]

functions.getSize = function(screen)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end
    
    -- # Code:
    return screen.width, screen.height
end

--[[
# Function: 'write', Documentation:

This function is used to write information to the
screen provided.

> Parameters:
<Parameter>   | TYPE         | Information:
--------------+--------------+-------------
<screen>      | TABLE OBJECT | Your screen object.
<text>        | STRING       | The text to write to the screen.
<override>    | BOOLEAN      | Whether or not to ignore level logic.
<transparent> | BOOLEAN      | Whether or not to update the screen pixels when writing.
--------------+--------------+-------------

> Returns:
@return: <nil>

> Notes:
Use the override boolean to ignore level checking and borders.
Use the transparent boolean to prevent the screen pixels from
being updated. Useful for screen refreshes as it bypasses
screen re-writing.

<>
]]

functions.write = function(screen, text, override, transparent)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end
    
    -- # Declaring Local Variables:
    local word                = tostring(text)
    local pixel               = text
    local override            = override or false
    local hook, wrap          = nil, screen:hook()
    local transparent         = transparent or false
    local xPos, yPos          = screen.curX - 1, screen.curY
    local stc, sbc, scp, spit = screen.display.setTextColor, screen.display.setBackgroundColor, screen.display.setCursorPos, screen.display.write

    -- $ Implement Screen Visibility Checking Here...

    -- # Checking Local Variables:
    if override == "override" then override = true end
    if transparent == "transparent" then transparent = true end
    if type(override) ~= "boolean" then override = false end
    if type(transparent) ~= "boolean" then transparent = false end
    if type(pixel) ~= "table" or not pixel["xPos"] and not pixel["yPos"] then
        pixel = false
    end

    -- # Code:
    screen.display.setTextColor(screen.foreground)
    screen.display.setBackgroundColor(screen.background)

    if screen.isParent then
        hook = screen.terminal
    elseif not screen.isParent and screen.display ~= screen.parent.display then
        hook = screen.parent.displays[screen.display]
    elseif not screen.isParent then
        hook = screen.parent.terminal
    end

    local letter, sPixel, tPixel = nil, nil, nil
    if not pixel then
        for i = 1, word:len() do
            letter = string.sub(word, i, i)
            sPixel = screen(xPos + i, yPos)

            -- # Ensure Pixel Exists:
            if not sPixel and not transparent then
                for i = 1, word:len() do
                    local letter = string.sub(word, i, i)
                    local x, y = wrap.revert(xPos + i - screen.startX + 1, yPos)
                    screen.buffer[#screen.buffer + 1] = {
                        ["xPos"] = x,
                        ["yPos"] = y,
                        ["text"] = letter,
                        ["level"] = screen.level,
                        ["foreground"] = tonumber(screen.foreground),
                        ["background"] = tonumber(screen.background),
                        ["display"] = tostring(screen.display)    
                    }
                end
                break
            elseif not sPixel then
                break
            end

            tPixel = hook[sPixel["yPos"]][sPixel["xPos"]]
    
            -- # Ensure Pixels are Within Level Bounds, is Visible, & Check if Pixel Needs Update:
            if not transparent then
                if sPixel["level"] >= tPixel["level"] and screen.isVisible or override then
                    if letter ~= tPixel["text"] or screen.foreground ~= tPixel["foreground"] or screen.background ~= tPixel["background"] or override then
                        scp(sPixel["xPos"], sPixel["yPos"])
                        spit(letter)

                        tPixel["foreground"] = tonumber(screen.foreground)
                        tPixel["background"] = tonumber(screen.background)
                        tPixel["level"] = tonumber(sPixel["level"])
                        tPixel["text"] = letter
                        tPixel["screen"] = tostring(screen)
                    end
                end

                sPixel["foreground"] = screen.foreground
                sPixel["background"] = screen.background
                sPixel["text"] = letter
            elseif sPixel["level"] >= tPixel["level"] and screen.isVisible or override then
                scp(sPixel["xPos"], sPixel["yPos"])
                spit(letter)
    
                tPixel["foreground"] = tonumber(screen.foreground)
                --tPixel["background"] = tonumber(screen.background)
                tPixel["level"] = tonumber(sPixel["level"])
                tPixel["text"] = letter
                tPixel["screen"] = tostring(screen)
            end
    
            -- # Update Current Screen Position:
            if xPos + i + 1 <= screen.width then
                screen.curX, screen.curY = xPos + i + 1, yPos
            else
                screen.curX, screen.curY = screen.width, yPos
            end
        end
    else
        tPixel = hook[pixel["yPos"]][pixel["xPos"]]

        if not transparent then
            if pixel["level"] >= tPixel["level"] and screen.isVisible or override then
                if pixel["text"] ~= tPixel["text"] or pixel["foreground"] ~= tPixel["foreground"] or pixel["background"] ~= tPixel["background"] or override then
                    sbc(pixel["background"])
                    stc(pixel["foreground"])
                    scp(pixel["xPos"], pixel["yPos"])
                    spit(pixel["text"])
                    
                    tPixel["foreground"] = tonumber(pixel["foreground"])
                    tPixel["background"] = tonumber(pixel["background"])
                    tPixel["level"] = tonumber(pixel["level"])
                    tPixel["text"] = pixel["text"]
                    tPixel["screen"] = tostring(screen)
                end
            end
        elseif pixel["level"] >= tPixel["level"] and screen.isVisible or override then
            sbc(pixel["background"])
            stc(pixel["foreground"])
            scp(pixel["xPos"], pixel["yPos"])
            spit(pixel["text"])

            tPixel["foreground"] = tonumber(pixel["foreground"])
            --tPixel["background"] = tonumber(pixel["background"])
            tPixel["level"] = tonumber(pixel["level"])
            tPixel["text"] = pixel["text"]
            tPixel["screen"] = tostring(screen)
        end

        -- # Update Current Screen Position:
        if pixel["xPos"] + 1 <= screen.width then
            screen.curX, screen.curY = pixel["xPos"] + 1, yPos
        else
            screen.curX, screen.curY = screen.width, yPos
        end
    end
end

--[[
# Function: 'blit', Documentation:

This function is used to write information to the
screen using the specified text and background colors.

> Parameters:
<Parameter>   | TYPE         | Information:
--------------+--------------+-------------
<screen>      | TABLE OBJECT | Your screen object.
<text>        | STRING       | The text to write to the screen.
<tCols>       | STRING       | Specify color codes for each individual text character for foreground.
<bCols>       | STRING       | Specify color codes for each individual text character for background.
<override>    | BOOLEAN      | Whether or not to ignore level logic.
<transparent> | BOOLEAN      | Whether or not to update the pixels when writing.
--------------+--------------+-------------

> Returns:
@return: <nil>

> Notes:
Each character in the text/background color strings must be a valid "paint" symbol 
from ComputerCraft's list of colors (e.g., "a" for purple, "3" for light blue, "e" for red, etc.), 
in the same order as the text characters they are to be applied to. Spaces may also be used: 
in the text color string, they'll be taken for white, whereas in the background color string 
they'll be taken for black. The three strings must each be of the same length.

<>
]]

functions.blit = function(screen, text, tCols, bCols, override, transparent)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end
    
    -- # Declaring Local Variables:
    local x, y        = screen.curX - 1, screen.curY
    local terminal    = screen:hook()
    
    if not override then
        override = false
    elseif override == "override" then
        override = true
    end

    if not transparent then
        transparent = false
    elseif transparent == "transparent" then
        transparent = true
    end

    -- # Checking Local Variables:
    if Debugger.check then
        Debugger.check(text, "text", "string")
        Debugger.check(tCols, "tCols", "string")
        Debugger.check(bCols, "bCols", "string")
        Debugger.check(override, "override", "boolean")
        Debugger.check(transparent, "transparent", "boolean")
    end

    if text:len() ~= tCols:len() then
        error("['text': "..#text.."] does not match the length of, ['tCols': "..#tCols.."]", 2)
    end

    if text:len() ~= bCols:len() then
        error("['text': "..#text.."] does not match the length of, ['bCols': "..#bCols.."]", 2)
    end

    -- # Code:
    local function convert(ID, ground)
        if ID == "0" then return colors.white
        elseif ID == "1" then return colors.orange
        elseif ID == "2" then return colors.magenta
        elseif ID == "3" then return colors.lightBlue
        elseif ID == "4" then return colors.yellow
        elseif ID == "5" then return colors.lime
        elseif ID == "6" then return colors.pink
        elseif ID == "7" then return colors.gray
        elseif ID == "8" then return colors.lightGray
        elseif ID == "9" then return colors.cyan
        elseif ID == "a" then return colors.purple
        elseif ID == "b" then return colors.blue
        elseif ID == "c" then return colors.brown
        elseif ID == "d" then return colors.green
        elseif ID == "e" then return colors.red
        elseif ID == "f" then return colors.black 
        elseif ID == " " then
            if ground == "foreground" then
                return colors.white
            elseif ground == "background" then
                return colors.black
            end 
        end
    end

    local stc, sbc, scp, spit = terminal.setTextColor, terminal.setBackgroundColor, terminal.setCursorPos, terminal.write
    local letter, tCol, bCol = nil, nil, nil
    
    for i = 1, #text do
        letter, tCol, bCol = text:sub(i, i), convert(tCols:sub(i, i), "foreground"), convert(bCols:sub(i, i), "background")
        scp(x + i, y)
        stc(tCol)
        sbc(bCol)
        spit(letter, override, transparent)
    end
end

--[[
# Function: 'setCursorBlink', Documentation:

This function is used to turn on off the blinker
of your passed screen.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<blink>     | BOOLEAN      | Whether or not to blink.
------------+--------------+-------------

> Returns:
@return: <nil>

<>
]]

functions.setCursorBlink = function(screen, blink)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Declaring Local Variables:
    local terminal = screen:hook()

    -- # Checking Local Variables:
    if Debugger.check then
        Debugger.check(blink, "blink", "boolean")
    end

    -- # Code:
    local x, y = terminal.revert(screen.curX, screen.curY)

    screen.display.setCursorPos(x, y)
    screen.display.setTextColor(screen.foreground)
    screen.display.setCursorBlink(blink)
end

--[[
# Function: 'isColor', Documentation:

This function is used to check if a screen
is colorable. 

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
------------+--------------+-------------

> Returns:
@return: <boolean>
@info  : Returns 'true' if colorable, 'false' otherwise.

<>
]]

functions.isColor = function(screen)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Code:
    return screen.display.isColor()
end

functions.isColour = functions.isColor

--[[
# Function: 'scroll', Documentation:

This function is used to scroll the text on
the screen by 'n' number of lines vertically.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<nLines>    | NUMBER       | Amount of lines to scroll.
------------+--------------+-------------

> Returns:
@return: <nil>

> Notes:
1: A positive nLines will move text up on the screen.
2: A negative nLines will move text down on the screen.

<>
]]

functions.scroll = function(screen, nLines)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Checking Variables:
    if Debugger.check then
        Debugger.check(nLines, "nLines", "number")
    end

    -- # Declaring Local Variables:
    local proxy, update    = {}, {}
    local terminal, sLine  = screen:hook(), tostring(nLines)
    local spit, convert    = terminal.write, terminal.convert
    local moveDown, moveUp = false, false

    -- # Code:
    -- > Repeat Calls Dependent on nLines:
    if nLines == 0 then return end
    if nLines > 1 or nLines < -1 then
        if nLines > 1 then
            for i = 1, nLines do
                functions.scroll(screen, 1)
            end
            return
        else
            local str = string.gsub(tostring(nLines), "-", "")
            local positive = tonumber(str)
            for i = 1, positive do
                functions.scroll(screen, -1)
            end
            return
        end
    end

    -- > Update Buffer & Find Inbound Pixels:
    local pixel, kill, keys, values   = nil, {}, {}, {}
    local overUp, overDown, stretched = false, false, false

    if #screen.buffer > 0 then
        for i = 1, #screen.buffer do
            pixel = screen.buffer[i]
            pixel["yPos"] = pixel["yPos"] - nLines
            
            if pixel["yPos"] >= screen.endY then
                overDown = true
            elseif pixel["yPos"] <= screen.startY then
                overUp = true
            end

            if pixel["yPos"] >= screen.endY or pixel["yPos"] <= screen.startY and pixel["xPos"] >= screen.startX and pixel["xPos"] <= screen.endX then
                stretched = true
            end

            if pixel["yPos"] == screen.startY and pixel["xPos"] >= screen.startX and pixel["xPos"] <= screen.endX then
                table.insert(update, pixel)
                kill[#kill + 1] = i
                moveDown = true
            elseif pixel["yPos"] == screen.endY and pixel["xPos"] >= screen.startX and pixel["xPos"] <= screen.endX then
                table.insert(update, pixel)
                kill[#kill + 1] = i
                moveUp = true
            end
        end

        if overDown and overUp then
            screen.stuffed = true
        else
            if #screen.buffer == 0 then
                screen.stuffed = false
            end
        end

        if #kill > 0 then
            for i = 1, #kill do
                screen.buffer[kill[i]] = nil
            end
        end
        
        for i in pairs(screen.buffer) do
            table.insert(keys, i)
        end

        table.sort(keys)

        for i = 1, #keys do
            values[i] = screen.buffer[keys[i]]
        end

        screen.buffer = values
    end

    -- > Update Inbound Pixels & Push to Buffer:
    -- > A "-" means when the substraction is made, it becomes addition due to double negatives.
    -- > So, a yPos of 15 becomes a yPos of 16 if the nLines was [-1].
    if sLine:find("-") then
        for y = screen.height, 1, -1 do
            for x = 1, screen.width do
                proxy = {}
    
                for k, v in pairs(screen.pixels[y][x]) do
                    proxy[k] = v
                end
                
                proxy["yPos"] = proxy["yPos"] - nLines

                if y == screen.height and not proxy["buffed"] then
                    screen.buffer[#screen.buffer + 1] = proxy
                elseif y == 1 and not moveDown and not overDown or y == 1 and screen.stuffed or y == 1 and stretched then
                    screen.pixels[y - nLines][x] = proxy
                    screen.pixels[y][x] = {
                        ["xPos"] = proxy["xPos"],
                        ["yPos"] = proxy["yPos"] + nLines,
                        ["text"] = " ",
                        ["level"] = screen.level,
                        ["foreground"] = screen.foreground,
                        ["background"] = screen.background,
                        ["display"] = tostring(screen.display),
                        ["buffed"] = true
                    }
                elseif y ~= screen.height then
                    screen.pixels[y - nLines][x] = proxy
                end
            end
        end
    else
        for y = 1, screen.height do
            for x = 1, screen.width do
                proxy = {}

                for k, v in pairs(screen.pixels[y][x]) do
                    proxy[k] = v
                end

                proxy["yPos"] = proxy["yPos"] - nLines

                if y == 1 and not proxy["buffed"] then
                    screen.buffer[#screen.buffer + 1] = proxy
                elseif y == screen.height and not moveUp and not overUp or y == screen.height and screen.stuffed or y == screen.height and stretched then
                    screen.pixels[y - nLines][x] = proxy
                    screen.pixels[y][x] = {
                        ["xPos"] = proxy["xPos"],
                        ["yPos"] = proxy["yPos"] + nLines,
                        ["text"] = " ",
                        ["level"] = screen.level,
                        ["foreground"] = screen.foreground,
                        ["background"] = screen.background,
                        ["display"] = tostring(screen.display),
                        ["buffed"] = true
                    }
                elseif y ~= 1 then
                    screen.pixels[y - nLines][x] = proxy
                end
            end
        end
    end

    -- > Update Incoming Inbound Pixels to Screen:
    local convX, convY = 0, 0
    if #update > 0 then
        for i = 1, #update do
            pixel = update[i]
            convX, convY = convert(pixel["xPos"], pixel["yPos"])
            screen.pixels[convY][convX] = pixel
        end
    end

    -- > Draw Updated Pixels:
    for y = 1, #screen.pixels do
        for x = 1, #screen.pixels[y] do
            spit(screen.pixels[y][x])
        end
    end
end

--[[
# Function: 'stretch', Documentation:

This function is used to scroll the text on
the screen by 'n' number of lines horizontally.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<nLines>    | NUMBER       | Amount of lines to scroll.
------------+--------------+-------------

> Returns:
@return: <nil>

> Notes:
1: A negative nLines will move text right on the screen.
2: A positive nLines will move text left on the screen.

<>
]]

functions.stretch = function(screen, nLines)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Checking Variables:
    if Debugger.check then
        Debugger.check(nLines, "nLines", "number")
    end

    -- # Declaring Local Variables:
    local proxy, update       = {}, {}
    local terminal, sLine     = screen:hook(), tostring(nLines)
    local spit, convert       = terminal.write, terminal.convert
    local moveLeft, moveRight = false, false

    -- # Code:
    -- > Repeat Calls Dependent on nLines:
    if nLines == 0 then return end
    if nLines > 1 or nLines < -1 then
        if nLines > 1 then
            for i = 1, nLines do
                functions.stretch(screen, 1)
            end
            return
        else
            local str = string.gsub(tostring(nLines), "-", "")
            local positive = tonumber(str)
            for i = 1, positive do
                functions.stretch(screen, -1)
            end
            return
        end
    end

    -- > Update Buffer & Find Inbound Pixels:
    local pixel, kill, keys, values      = nil, {}, {}, {}
    local overRight, overLeft, stretched = false, false, false

    if #screen.buffer > 0 then
        for i = 1, #screen.buffer do
            pixel = screen.buffer[i]
            pixel["xPos"] = pixel["xPos"] - nLines
            
            if pixel["xPos"] >= screen.endX then
                overLeft = true
            elseif pixel["xPos"] <= screen.startX then
                overRight = true
            end

            if pixel["xPos"] >= screen.endX or pixel["xPos"] <= screen.startX and pixel["yPos"] >= screen.startY and pixel["yPos"] <= screen.endY then
                stretched = true
            end

            if pixel["xPos"] == screen.startX and pixel["yPos"] >= screen.startY and pixel["yPos"] <= screen.endY then
                table.insert(update, pixel)
                kill[#kill + 1] = i
                moveLeft = true
            elseif pixel["xPos"] == screen.endX and pixel["yPos"] >= screen.startY and pixel["yPos"] <= screen.endY then
                table.insert(update, pixel)
                kill[#kill + 1] = i
                moveRight = true
            end
        end

        if overLeft and overRight then
            screen.stuffed = true
        else
            if #screen.buffer == 0 then
                screen.stuffed = false
            end
        end

        if #kill > 0 then
            for i = 1, #kill do
                screen.buffer[kill[i]] = nil
            end
        end
        
        for i in pairs(screen.buffer) do
            table.insert(keys, i)
        end

        table.sort(keys)

        for i = 1, #keys do
            values[i] = screen.buffer[keys[i]]
        end

        screen.buffer = values
    end

    -- > Update Inbound Pixels & Push to Buffer:
    -- > A "-" means when the substraction is made, it becomes addition due to double negatives.
    -- > So, a xPos of 15 becomes a xPos of 16 if the nLines was [-1].
    if sLine:find("-") then
        for x = screen.width, 1, -1 do
            for y = 1, screen.height do
                proxy = {}

                for k, v in pairs(screen.pixels[y][x]) do
                    proxy[k] = v
                end
                
                proxy["xPos"] = proxy["xPos"] - nLines

                if x == screen.width and not proxy["buffer"] then
                    screen.buffer[#screen.buffer + 1] = proxy
                elseif x == 1 and not moveLeft and not overLeft or x == 1 and screen.stuffed or x == 1 and stretched then
                    screen.pixels[y][x - nLines] = proxy
                    screen.pixels[y][x] = {
                        ["xPos"] = proxy["xPos"] + nLines,
                        ["yPos"] = proxy["yPos"],
                        ["text"] = " ",
                        ["level"] = screen.level,
                        ["foreground"] = screen.foreground,
                        ["background"] = screen.background,
                        ["display"] = tostring(screen.display),
                        ["buffed"] = true
                    }
                elseif x ~= screen.width then
                    screen.pixels[y][x - nLines] = proxy
                end
            end
        end
    else
        for x = 1, screen.width do
            for y = 1, screen.height do
                proxy = {}

                for k, v in pairs(screen.pixels[y][x]) do
                    proxy[k] = v
                end

                proxy["xPos"] = proxy["xPos"] - nLines

                if x == 1 and not proxy["buffer"] then
                    screen.buffer[#screen.buffer + 1] = proxy
                elseif x == screen.width and not moveRight and not overRight or x == screen.width and screen.stuffed or x == screen.width and stretched then
                    screen.pixels[y][x - nLines] = proxy
                    screen.pixels[y][x] = {
                        ["xPos"] = proxy["xPos"] + nLines,
                        ["yPos"] = proxy["yPos"],
                        ["text"] = " ",
                        ["level"] = screen.level,
                        ["foreground"] = screen.foreground,
                        ["background"] = screen.background,
                        ["display"] = tostring(screen.display),
                        ["buffed"] = true
                    }
                elseif x ~= 1 then
                    screen.pixels[y][x - nLines] = proxy
                end
            end
        end
    end

    -- > Update Incoming Inbound Pixels to Screen:
    local convX, convY = 0, 0
    if #update > 0 then
        for i = 1, #update do
            pixel = update[i]
            convX, convY = convert(pixel["xPos"], pixel["yPos"])
            screen.pixels[convY][convX] = pixel
        end
    end

    -- > Draw Updated Pixels:
    for y = 1, #screen.pixels do
        for x = 1, #screen.pixels[y] do
            spit(screen.pixels[y][x])
        end
    end
end

--[[
# Function: 'redirect', Documentation:

This function is used to change terminal output 
to another terminal object. 

> Parameters:
<Parameter> | TYPE            | Information:
------------+-----------------+-------------
<screen>    | TABLE OBJECT    | Your screen object.
<target>    | TERMINAL OBJECT | The terminal to redirect to.
------------+-----------------+-------------

> Returns:
@return: <table>
@info  : Returns previous terminal object.

> Notes:
If the parent is re-directed to a different display,
the children will follow, and all future term calls 
on children will be done on the redirected display. 
However, any pervious terminal writes will remain.

If a child is re-directed, then its display is disconnected
from the parent's, and is assigned to the target provided.
Additonally, the parent will receive a new "terminal" table
with the tostring of the target in memory. Everytime a redirect
is performed, it will check if any displays have become 'obsolete'.

<>
]]

functions.redirect = function(screen, target)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Checking Variables:
    if type(target) ~= "table" then
        error("['target'] is not valid. Expected object; got <"..tostring(target)..">, as type '"..type(target).."'.", 2)
    end

    if screen.isParent and target.isScreen and not target.isParent then
        error("['target'] is not valid. Parent can not be redirected to children.", 2)
    end

    -- # Declaring Local Variables:
    local prevW, prevH = screen.width, screen.height
    local prevTarget   = tostring(screen.display)
    local hook         = screen:hook()
    local w, h         = target.getSize()

    -- # Code:
    -- > Update Screen Object Variables for New Display:
    screen.display = target
    if screen.isParent then
        screen.width = w
        screen.height = h
        screen.size = w * h
        screen.endX = w
        screen.endY = h
    elseif not screen.isParent then
        if screen.width > w then
            screen.width = w
            screen.endX = w
        end
        if screen.height > h then
            screen.height = h
            screen.endY = h
        end
        screen.size = screen.width * screen.height
    end

    -- # Remove Inapplicable Pixels if Applicable:
    if prevW - w > 0 then
        for y = 1, h do
            for x = w, prevW do
                screen.pixels[y][x] = nil
                if screen.isParent then
                    screen.terminal[y][x] = nil
                end
            end
        end
    end

    if prevH - h > 0 then
        for y = h, prevH do
            for x = 1, w do
                screen.pixels[y][x] = nil
                if screen.isParent then
                    screen.terminal[y][x] = nil
                end
            end
        end
    end

    -- # Update Parent Pixel & Terminal Table for New Coords if Applicable:
    if screen.isParent then
        for y = 1, h do
            screen.pixels[y] = {}
            screen.terminal[y] = {}
            for x = 1, w do
                if not screen(x, y) then
                    screen.pixels[y][x] = {
                        ["xPos"] = x,
                        ["yPos"] = y,
                        ["text"] = "",
                        ["level"] = screen.level,
                        ["foreground"] = foreground,
                        ["background"] = background,
                        ["display"] = tostring(target)
                    }
                    screen.terminal[y][x] = {
                        ["xPos"] = x,
                        ["yPos"] = y,
                        ["text"] = "",
                        ["level"] = screen.level,
                        ["foreground"] = foreground,
                        ["background"] = background,
                        ["display"] = tostring(target),
                        ["screen"] = ""
                    }
                else
                    screen.pixels[y][x]["display"] = tostring(target)
                end
            end
        end
    end

    -- # Update Child Pixel Table for New Coords if Applicable:
    if not screen.isParent then
        local curX, curY = 0, 0
        for y = 1, screen.height do
            curY = screen.startY + y - 1
            screen.pixels[y] = {}
            for x = 1, screen.width do
                curX = screen.startX + x - 1

                if x > screen.width or x > w or y > screen.height or y > h then
                    break
                end 

                screen.pixels[y][x] = {
                    ["xPos"] = curX,
                    ["yPos"] = curY,
                    ["text"] = "",
                    ["level"] = screen.level,
                    ["foreground"] = foreground,
                    ["background"] = background,
                    ["display"] = tostring(target)
                }
            end
        end

        -- > Build Terminal Table in Parent's Display Memory if Applicable:
        if tostring(target) ~= screen.parent.display then
            screen.parent.displays[tostring(target)] = {}
    
            for y = 1, h do
                screen.parent.displays[tostring(target)][y] = {}
                for x = 1, w do
                    screen.parent.displays[tostring(target)][y][x] = {
                        ["xPos"] = x,
                        ["yPos"] = y,
                        ["text"] = "",
                        ["level"] = screen.level,
                        ["foreground"] = foreground,
                        ["background"] = background,
                        ["display"] = tostring(target),
                        ["screen"] = ""
                    }
                end
            end
        else
            local kill = false
            for i = 1, #screen.parent.children do
                if screen.parent.children[i]["display"] == prevTarget then
                    kill = false
                    break
                end
                kill = true
            end
            if kill then screen.parent.displays[prevTarget] = nil end
        end
    end

    -- > Check if Buffed Pixels Can be Applied to New Screen Size:
    local pixel, kill, x, y = nil, {}, 0, 0
    if #screen.buffer > 0 then
        for i = 1, #screen.buffer do
            pixel = screen.buffer[i]

            if pixel["xPos"] >= screen.startX and pixel["xPos"] <= screen.endX and pixel["yPos"] >= screen.startY and pixel["yPos"] <= screen.endY then
                x, y = hook.convert(pixel["xPos"], pixel["yPos"])
                screen.pixels[y][x] = pixel
                kill[#kill + 1] = i
            end
        end
        if #kill > 0 then
            for i = 1, #kill do
                screen.buffer[kill[i]] = nil
            end
        end
    end

    -- # Update Children if Parent & if Applicable:
    if screen.isParent then
        if #screen.children > 0 then
            for i = 1, #screen.children do
                screen.children[i]["display"] = target
            end
        end
    end

    -- # Return New Display Reference:
    return screen.display
end

--[[
# Function: 'current', Documentation:

This function returns the current terminal object.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
------------+--------------+-------------

> Returns:
@return: <table>
@info  : Returns current terminal object.

<>
]]

functions.current = function(screen)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Code:
    return screen.display
end

--[[
# Function: 'native', Documentation:

This function returns the native terminal object,
and re-assigns the current screen's display to
the native terminal object.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
------------+--------------+-------------

> Returns:
@return: <table>
@info  : Returns native terminal object.

> Notes:
If a child is using the native call, it will reset
its display back to the parent's display, and will
return that display.

<>
]]

functions.native = function(screen)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Declaring Local Variables:
    local native = nil

    -- # Code:
    if screen.isParent then
        native = screen.display.native()
        screen.display = native
    elseif not screen.isParent then
        native = screen.parent.display
        screen.display = native
    end

    return native
end

--[[
# Function: 'changelevel', Documentation:

This function is used to change the level of the
pixels on the screen provided. 

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<level>     | NUMBER       | The new level to set your screen to.
------------+--------------+-------------

> Returns:
@return: <nil>

<>
]]

functions.changelevel = function(screen, level)
    -- $ Developer Note:
    -- > Major rewrite is now possible due to newly
    -- > implemented visibility rules among screens.
    
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Declaring Local Variables:
    local width, height, parent = screen.width, screen.height, nil

    -- # Code:
    -- > Apply Width & Height Patches on Children:
    if not screen.isParent then
        parent = screen.parent
    else
        parent = screen
    end

    local function find_screen(ID)
        for i = 1, #parent.children do
            if ID == tostring(parent.children[i]) then
                return parent.children[i]
            end
        end
        return false
    end

    -- > Update 'From' Level for Tracking:
    screen.from = screen.level

    -- > Update Screen Pixels:
    local kill, pixel, kid = false, false, nil
    for y = 1, height do
        for x = 1, width do
            pixel = screen(x, y)
            if not pixel then 
                kill = true 
                break 
            end

            pixel["level"] = level
            kid = find_screen(parent.terminal[pixel["yPos"]][pixel["xPos"]]["screen"])
            if kid then
                if kid.from < level or kid.from == kid.level then
                    parent.terminal[pixel["yPos"]][pixel["xPos"]]["level"] = level
                end
            else
                parent.terminal[pixel["yPos"]][pixel["xPos"]]["level"] = level
            end
        end
        if kill then break end
    end
    
    -- > Update Screen Level:
    screen.level = level
end

--[[
# Function: 'scanlevel', Documentation:

This function is used to see if the pixel called
is above all other screens, according to pixel levels.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<x>         | NUMBER       | The screen x position.
<y>         | NUMBER       | The screen y position.
------------+--------------+-------------

> Returns:
@return: <boolean>
@info  : Returns 'true' if pixel is above all other
screens; 'false' otherwise.

<>
]]

functions.scanlevel = function(screen, x, y)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Declaring Local Variables:
    local x = x or nil
    local y = y or nil
    local children = nil
    local hook = screen:hook()

    -- # Checking Variables:
    if type(x) ~= "number" then error("[x] must be type: 'number'; got "..type(x), 2) end
    if type(y) ~= "number" then error("[y] must be type: 'number'; got "..type(y), 2) end

    -- # Code:
    if screen.isParent then
        children = screen.children
    else
        if screen.parent.level > screen.level then
            return false
        end
        children = screen.parent.children
        x, y = hook.revert(x, y)
    end

    -- # Checking all Screens:
    local pixel = nil
    local convX, convY = 0, 0
    for i = 1, #children do
        if screen.isParent then
            convX, convY = screen.convert(children[i], x, y)
        else
            convX, convY = screen.parent.convert(children[i], x, y)
        end
        if convX then
            pixel = children[i](convX, convY)
            if pixel and pixel["level"] > screen.level then
                return false
            end
        end
    end
    return true
end

--[[
# Function: 'convert', Documentation:

This function is used to convert native terminal coords
into screen coords. Useful for event pulls, and API
interfacing. 

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<x>         | NUMBER       | The native x position.
<y>         | NUMBER       | The native y position.
------------+--------------+-------------

> Returns:
@return: <x>, <y>
@info  : The x and y values returned will be 
the position on the screen provided.

<>
]]

functions.convert = function(screen, x, y)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Declaring Local Variables:
    local x = x or nil
    local y = y or nil

    -- # Checking Variables:
    if type(x) ~= "number" then error("[x] must be type: 'number'; got "..type(x), 2) end
    if type(y) ~= "number" then error("[y] must be type: 'number'; got "..type(y), 2) end

    -- # Code:
    if x < screen.startX then
        error("[x: "..tostring(x).."] is below screen range: ["..screen.startX.."]", 2)
    elseif x > screen.startX then
        x = x - screen.startX + 1
    elseif x == screen.startX then
        x = 1
    end

    if y < screen.startY then
        error("[y: "..tostring(y).."] below screen domain: ["..screen.startY.."]", 2)
    elseif y > screen.startY then
        y = y - screen.startY + 1
    elseif y == screen.startY then
        y = 1
    end

    return x, y
end

--[[
# Function: 'revert', Documentation:

This function is used to revert screen coords into
native terminal coords. Useful for event pulls, and API
interfacing. 

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<x>         | NUMBER       | The screen x position.
<y>         | NUMBER       | The screen y position.
------------+--------------+-------------

> Returns:
@return: <x>, <y>
@info  : The x and y values returned will be 
the position on the native terminal.

<>
]]

functions.revert = function(screen, x, y)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Declaring Local Variables:
    local x = x or nil
    local y = y or nil

    -- # Checking Variables:
    if type(x) ~= "number" then error("[x] must be type: 'number'; got "..type(x), 2) end
    if type(y) ~= "number" then error("[y] must be type: 'number'; got "..type(y), 2) end

    -- # Code:
    local pixel = screen(x, y)
    if pixel then
        x = pixel["xPos"]
        y = pixel["yPos"]

        return x, y
    else
        return (x + screen.startX) - 1, (y + screen.startY) - 1
    end
end

--[[
# Function: 'resize', Documentation:

This function is used to resize a child screen.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your child screen object.
<startX>    | NUMBER       | The new startX position.
<startY>    | NUMBER       | The new startY position.
<width>     | NUMBER       | The new endX position.
<height>    | NUMBER       | The new endY position.
<level>     | NUMBER       | Whether or not to update the level of the screen.
------------+--------------+-------------

> Returns:
@return: <boolean success>
@info  : This function will return whether or not
         the resize was successful.

> Notes:
1: The parent cannot be resized since it holds
native screen information that is required for
logical operations to execute successfully.

2: The <level> parameter is optional, and will be
defaulted if a new level argument is not provided.

<>
]]

functions.resize = function(child, startX, startY, width, height, level)
    -- # Checking Screen:
    if type(child) ~= "table" or not child.isScreen then error("['child'] was not defined!", 2) end
    if child.isParent then error("['child'] cannot be the parent, only children of the parent can be resized!", 2) end

    -- # Declaring Local Variables:
    local hook       = child:hook()
    local level      = level or child.level
    local curX, curY = 0, 0

    -- # Checking Local Variables:
    if Debugger.check then
        Debugger.check(startX, "['startX']", "number")
        Debugger.check(startY, "['startY']", "number")
        Debugger.check(width, "['width']", "number")
        Debugger.check(height, "['height']", "number")
        Debugger.check(level, "['level']", "number")
    end

    if width <= 0 then
        return error("width: "..width..", cannot be less than 1", 2)
    elseif height <= 0 then
        return error("height: "..height..", cannot be less than 1", 2)
    end

    -- # Code:
    -- > Drop Terminal Table Levels Before Resize:
    local terminal = nil
    if child.display == child.parent.display then
        terminal = child.parent.terminal
    else
        terminal = child.parent.displays[child.display]
    end

    for y = child.startY, child.endY do
        for x = child.startX, child.endX do
            terminal[y][x]["level"] = child.parent.level
        end
    end

    -- > Update Child Table:
    child.width = width
    child.height = height
    child.size = width * height
    child.startX = startX
    child.startY = startY
    child.endX = startX + width - 1
    child.endY = startY + height - 1
    child.curX = 1
    child.curY = 1
    child.level = level
    child.pixels = {}

    -- > Update Pixels:
    for y = 1, height do
        curY = startY + y - 1
        if curY > child.parent.height then 
            break
        end
        child.pixels[y] = {}
        for x = 1, width do
            curX = startX + x - 1
            if curX > child.parent.width then
                break
            end

            child.pixels[y][x] = {
                ["xPos"] = curX,
                ["yPos"] = curY,
                ["text"] = "",
                ["level"] = level,
                ["foreground"] = child.foreground,
                ["background"] = child.background,
                ["display"] = tostring(child.display)
            }
        end
    end

    -- > Check if Buffed Pixels Can be Applied to Screen:
    local pixel, kill, x, y = nil, {}, 0, 0
    if #child.buffer > 0 then
        for i = 1, #child.buffer do
            pixel = child.buffer[i]

            if pixel["xPos"] >= child.startX and pixel["xPos"] <= child.endX and pixel["yPos"] >= child.startY and pixel["yPos"] <= child.endY then
                x, y = hook.convert(pixel["xPos"], pixel["yPos"])
                child.pixels[y][x] = pixel
                kill[#kill + 1] = i
            end
        end
        if #kill > 0 then
            for i = 1, #kill do
                child.buffer[kill[i]] = nil
            end
        end
    end

    -- # Push an Event into the Queue that a Screen Resized:
    os.queueEvent("screen_resize")

    -- # Return Successful Resize:
    return true
end

--[[
# Function: 'refresh', Documentation:

This function is used to refresh the screen by
looping through all pixels, and applying updates
where necessary. To refresh all screens, pass
<true> to 'all' parameter.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<all>       | BOOLEAN      | Whether or not to refresh all screens.
------------+--------------+-------------

> Returns:
@return: <nil>

<>
]]

functions.refresh = function(screen, all)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Declaring Local Variables:
    local hook = screen:hook()
    local spit = hook.write

    -- # Code:
    -- # Draw Pixels:
    if not all then
        for y = 1, #screen.pixels do
            for x = 1, #screen.pixels[y] do
                spit(screen.pixels[y][x], false, false)
            end
        end
    else
        if screen.isParent then
            if #screen.children > 0 then
                for i = 1, #screen.children do
                    for y = 1, #screen.children[i].pixels do
                        for x = 1, #screen.children[i].pixels[y] do
                            spit(screen.children[i].pixels[y][x], false, false)
                        end
                    end
                end
            end
            for y = 1, #screen.pixels do
                for x = 1, #screen.pixels[y] do
                    spit(screen.pixels[y][x], false, false)
                end
            end
        else
            if #screen.parent.children > 0 then
                for i = 1, #screen.parent.children do
                    for y = 1, #screen.parent.children[i].pixels do
                        for x = 1, #screen.parent.children[i].pixels[y] do
                            spit(screen.parent.children[i].pixels[y][x], false, false)
                        end
                    end
                end
            end
            for y = 1, #screen.parent.pixels do
                for x = 1, #screen.parent.pixels[y] do
                    spit(screen.parent.pixels[y][x], false, false)
                end
            end
        end
    end
end

--[[
# Function: 'visible', Documentation:

This function is used to change the visibility of a
screen. If from visible to invisible, the pixels
will no longer be taken into account when writing
information to the screen. If visible, then information
will be considered when refreshing the screen.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<visible>   | BOOLEAN      | Whether or not to make the screen visible.
------------+--------------+-------------

> Returns:
@return: <boolean>
@info  : Returns 'false' if the screen to be changed was the parent.
It will return 'true' otherwise.

<>
]]

functions.visible = function(screen, visible)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Declaring Local Variables:
    local hook = screen:hook()
    local terminal = nil

    -- # Checking Declared Variables:
    if type(visible) ~= "boolean" then
        error("[visible] must be type <boolean>; got, ["..tostring(visible).."]; as type, ("..type(visible)..")", 2)
    end

    -- # Code:
    if screen.isParent then
        return false
    end

    if visible == true then
        screen.isVisible = true
        screen.level = screen.from
        
        for y = 1, screen.height do
            for x = 1, screen.width do
                screen.pixels[y][x]["level"] = screen.level
            end
        end
        if #screen.buttons > 0 then
            for i = 1, #screen.buttons do
                screen.buttons[i].isVisible = true
                screen.buttons[i].level = screen.buttons[i].from
                for y = 1, screen.buttons[i].height do
                    for x = 1, screen.buttons[i].width do
                        screen.buttons[i].pixels[y][x]["level"] = screen.buttons[i].level
                    end
                end
            end
        end
    else
        screen.isVisible = false
        screen.from = screen.level
        screen.level = screen.parent.level - 1

        -- # Update Screen:
        for y = 1, screen.height do
            for x = 1, screen.width do
                screen.pixels[y][x]["level"] = screen.level
            end
        end
        if #screen.buttons > 0 then
            for i = 1, #screen.buttons do
                screen.buttons[i].isVisible = false
                screen.buttons[i].from = screen.buttons[i].level
                screen.buttons[i].level = screen.buttons[i].parent.level - 1
                for y = 1, screen.buttons[i].height do
                    for x = 1, screen.buttons[i].width do
                        screen.buttons[i].pixels[y][x]["level"] = screen.buttons[i].level
                    end
                end
            end
        end

        -- # Update Terminal:
        for y = screen.startY, screen.endY do
            for x = screen.startX, screen.endX do
                screen.parent.terminal[y][x]["level"] = screen.level
            end
        end
    end

    return true
end

--[[
# Function: 'debug', Documentation:

This function is used to debug the terminal by pushing
its data to terminal debugging log. Refer to the C9
file in the environment root folder to check the directory
of where this file is currently located.

> Parameters:
<Parameter> | TYPE         | Information:
------------+--------------+-------------
<screen>    | TABLE OBJECT | Your screen object.
<file>      | STRING       | Where to write terminal data to.
------------+--------------+-------------

> Returns:
@return: <nil>

> Notes:
If no file is provided, the default terminal debugging
file is used.

<>
]]

functions.debug = function(screen, file)
    -- # Checking Screen:
    if type(screen) ~= "table" or not screen.isScreen then error("['screen'] was not defined!", 2) end

    -- # Declaring Local Variables:
    local ID, ext, terminal, displays = nil, nil, nil, nil
    if screen.isParent then
        ID = "Parent Screen <"..tostring(screen)..">:"
        terminal = screen.terminal
        displays = screen.displays
    elseif not screen.isParent then
        ID = "Child Screen <"..tostring(screen)..">; with Parent Screen <"..tostring(screen.parent)..">:"
        terminal = screen.parent.terminal
        displays = screen.parent.displays
    end

    -- # Checking Local Variables:
    if not file and C9 then
        file = C9.TERM_LOG 
    elseif file and not fs.exists(file) then
        error("['file'] does not exist!", 2)
    else
        file = "screen_debug"
        if not fs.exists(file) then
            local temp = fs.open(file, "w")
            temp.close()
        end
    end

    -- # Code:
    Debugger.log(file, "w", screen, ID, "pixels", "buffer", "children", "parent", "terminal", "displays", "buttons")
    
    if string.find(file, "%.") then
        ext  = string.match(file, "%..+")
        file = string.gsub(file, "%..+", "")
    else
        ext = ""
    end

    if not fs.exists(file..".pixels"..ext) then
        local temp = fs.open(file..".pixels"..ext, "w")
        temp.close()
    end
    if not fs.exists(file..".buffer"..ext) then
        local temp = fs.open(file..".buffer"..ext, "w")
        temp.close()
    end
    if not fs.exists(file..".terminal"..ext) then
        local temp = fs.open(file..".terminal"..ext, "w")
        temp.close()
    end
    if not fs.exists(file..".displays"..ext) then
        local temp = fs.open(file..".displays"..ext, "w")
        temp.close()
    end

    Debugger.log(file..".pixels"..ext, "w", screen.pixels, ID)
    Debugger.log(file..".buffer"..ext, "w", screen.buffer, ID)
    Debugger.log(file..".terminal"..ext, "w", terminal, ID)
    Debugger.log(file..".displays"..ext, "w", displays, ID)
end

--[[
# Function: 'add', Documentation:

This function is used to 'add' another screen to
the parent screen. 

> Parameters:
<Parameter>   | TYPE            | Information:
--------------+-----------------+-------------
<screen>      | TERMINAL OBJECT | Your parent object.
<startX>      | NUMBER          | The column to start your child screen in.
<startY>      | NUMBER          | The row to start your child screen in.
<width>       | NUMBER          | The width of your child screen.
<height>      | NUMBER          | The height of your child screen.
<foreground>  | NUMBER          | The font color of your child screen.
<background>  | NUMBER          | The background color of your child screen.
<level>       | NUMBER          | The priority of your screen. (Higher #s take priority!)
<hidden>      | BOOLEAN         | Whether or not the child screen is displayed when made.
<transparent> | BOOLEAN         | Whether or not your child screen is transparent.
--------------+-----------------+-------------

> Returns:
@return: <child screen>

> Notes:
1: To create a new screen, look at the following example:

<your child> = <your parent>:add(20, 15, colors.red, colors.white, 5, 5, 2, true)

This will return a new screen with a width of 20, a height of 15, a text color of red,
a background color of white, a native start terminal coordinate of (x: 5, y: 5), a screen level priority of 2, 
and a screen with transparent pixels. The screen's pixels will override the parent's pixels if the parent level 
is set to 1 or lower. However, since this screen is transparent, any screen with a lower level will display 
their pixels, if and only if, the higher level pixels have blank text and the same background color.
        
To use your child screen's functions, pass it as the first argument in your parent's
operational functions. Example:

<your parent>.setCursorPos(<your child>, x, y)

So for the above example, if I where to call:
<your parent>.setCursorPos(<your child>, 1, 1)

This would set the native cursor position at (5, 5) since the child's startX and startY position
is set to (5, 5) natively.
        
Children refer back to their parents for native information, performance, and logical operations. 
Children cannot act as parents, and are not capable of having children.

2: Caution: Any missing parameters will be defaulted, or will raise an error when making a child.

<>
]]

functions.add = function(parent, startX, startY, width, height, foreground, background, level, hidden, transparent)
    -- # Checking Parent:
    if type(parent) ~= "table" or not parent.isScreen then error("['parent'] was not defined!", 2) end

    -- # Defining Local Variables:
    local level       = level or parent.level + 1
    local addH, addW  = 1, 1
    local hidden      = hidden or false
    local isVisible   = true
    local transparent = transparent or false

    -- # Checking Local Variables:
    if Debugger.check then
        Debugger.check(width, "['width']", "number")
        Debugger.check(height, "['height']", "number")
        Debugger.check(foreground, "['foreground']", "number")
        Debugger.check(background, "['background']", "number")
        Debugger.check(startX, "['startX']", "number")
        Debugger.check(startY, "['startY']", "number")
        Debugger.check(level, "['level']", "number")
        Debugger.check(transparent, "['transparent']", "boolean")
    end

    if height == 1 then
        addH = 0
    end
    if width == 1 then
        addW = 0
    end
    if hidden then
        isVisible = false
    end

    -- # Build Child Screen Object:
    local Child = {
        ["display"] = parent.display,
        ["width"] = width,
        ["height"] = height,
        ["size"] = width * height,
        ["startX"] = startX,
        ["startY"] = startY,
        ["endX"] = startX + width - 1,
        ["endY"] = startY + height - 1,
        ["curX"] = 1,
        ["curY"] = 1,
        ["level"] = level,
        ["from"] = level,
        ["foreground"] = foreground,
        ["background"] = background,
        ["transparent"] = transparent,
        ["isScreen"] = true,
        ["isParent"] = false,
        ["isVisible"] = isVisible,
        ["stuffed"] = false,
        ["parent"] = parent,
        ["pixels"] = {},
        ["buffer"] = {},
        ["buttons"] = {}
    }

    if hidden then
        level = Child.parent.level - 1
    end

    -- # Create Pixels for Child:
    local curX, curY = 0, 0
    for y = 1, height do
        curY = startY + y - 1
        if curY > parent.height then 
            error("Child height exceeded the parent's! Parent Absolute Height: "..parent.height..", Child Added Height: "..curY, 2)
            break 
        end
        Child.pixels[y] = {}
        for x = 1, width do
            curX = startX + x - 1
            if curX > parent.width then
                error("Child width exceeded the parent's! Parent Absolute Width: "..parent.width..", Child Added Width: "..curX, 2)
                break
            end 

            Child.pixels[y][x] = {
                ["xPos"] = curX,
                ["yPos"] = curY,
                ["text"] = " ",
                ["level"] = level,
                ["foreground"] = foreground,
                ["background"] = background,
                ["display"] = tostring(Child.display)
            }
        end
    end

    -- # Ensure Child Cannot Become Parent:
    Child.add = function()
        error("Child screen cannot act as parent! Create another child via parent terminal.", 2)
    end

    -- # Redirect Self:Hook Calls to Parent & Return:
    Child.hook = function(Child)
        return parent.hook(Child)
    end

    -- # Hook Metamethods into Child:
    setmetatable(Child, {
        __call = function(_, x, y)
            if not Child["pixels"][y] then
                return nil
            elseif not Child["pixels"][y][x] then
                return nil
            end
            return Child["pixels"][y][x]
        end,

        -- # Note: This metamethod will work when CC moves to Lua 5.2. 
        --         Grab the screen size by directly calling <your child here>.size
        
        __len = function(t)
            return t.size
        end  
    })

    -- # Add Reference to Parent:
    table.insert(parent.children, Child)

    -- # Return Child to User:
    return Child
end

--[[END LOCAL FUNCTIONS ZONE]]--

--[[
# Function: 'new', Documentation:

This function is used to create a new parent screen.
The parent will take information from the terminal
provided.

> Parameters:
<Parameter> | TYPE            | Information:
------------+-----------------+-------------
<terminal>  | TERMINAL OBJECT | Your desired terminal to wrap.
------------+-----------------+-------------

> Returns:
@return: <parent screen>

> Notes:
If no terminal is provided, then the native terminal
will be defaulted to.

<>
]]

function new(terminal)
    -- # Defining Local Variables:
    local term       = terminal or term.native()
    local w, h       = term.getSize()
    local foreground = term.getTextColor()
    local background = term.getBackgroundColor()

    -- # Build Parent Screen Object:
    local Parent = {
        ["display"] = term,
        ["width"] = w,
        ["height"] = h,
        ["size"] = (w * h),
        ["startX"] = 1,
        ["startY"] = 1,
        ["endX"] = w,
        ["endY"] = h,
        ["curX"] = 1,
        ["curY"] = 1,
        ["level"] = 0,
        ["from"] = 0,
        ["foreground"] = foreground,
        ["background"] = background,
        ["transparent"] = false,
        ["isScreen"] = true,
        ["isParent"] = true,
        ["isVisible"] = true,
        ["stuffed"] = false,
        ["pixels"] = {},
        ["buffer"] = {},
        ["buttons"] = {},
        ["children"] = {},
        ["terminal"] = {},
        ["displays"] = {}
    }

    -- # Populate Parent Pixel Table:
    for y = 1, h do
        Parent.pixels[y] = {}
        Parent.terminal[y] = {}
        for x = 1, w do
            Parent.pixels[y][x] = {
                ["xPos"] = x,
                ["yPos"] = y,
                ["text"] = " ",
                ["level"] = Parent.level,
                ["foreground"] = foreground,
                ["background"] = background,
                ["display"] = tostring(Parent.display)
            }
            Parent.terminal[y][x] = {
                ["xPos"] = x,
                ["yPos"] = y,
                ["text"] = "",
                ["level"] = Parent.level,
                ["foreground"] = foreground,
                ["background"] = background,
                ["display"] = tostring(Parent.display),
                ["screen"] = " "
            }
        end
    end

    -- # Wrap Custom Terminal Functions into Parent Screen:
    for index, instruction in pairs(functions) do
        Parent[index] = instruction
    end

    -- # Hook Metamethods into Parent Terminal:
    setmetatable(Parent, {
        __call = function(_, x, y)
            if not Parent["pixels"][y] then
                --return error("Pixel does not exist at: ["..tostring(x)..", "..tostring(y).."]")
                return nil
            elseif not Parent["pixels"][y][x] then
                return nil
            end
            return Parent["pixels"][y][x]
        end,

        -- # Note: This metamethod will work when CC moves to Lua 5.2. 
        --         Grab the pixel size by directly calling <your parent here>.size
        
        __len = function(t)
            return t.size
        end        
    })

    -- # Return Parent Screen:
    return Parent
end

-- End of Document