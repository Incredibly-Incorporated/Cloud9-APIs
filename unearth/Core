--[[
Unearth Documentation:

Thank you for using the Unearth turtle mining
program. All APIs & Interfaces are
documented in their corresponding files. 

Use the program's exclusive UI to quickly unearth
the ground, and get the resources that you need
quickly.

Updates will be available on the GitHub, and is
checked by terminals that have automatic updates
enabled. 
--]]

-- # Establish Reference for Assests in Global Environment:
_G.unearth = {}
-- $$ Check Notes...

-- # Program API Directory Files:
local APIS = {
    ["BUTTON"]      = "Cloud9-APIs/Button",
    ["CRAFT"]       = "Cloud9-APIs/Craft",
    ["DEBUGGER"]    = "Cloud9-APIs/Debugger",
    ["ENVIRONMENT"] = "Cloud9-APIs/Environment",
    ["SCREEN"]      = "Cloud9-APIs/Screen",
    ["TEXT"]        = "Cloud9-APIs/Text",
    ["WINDOW"]      = "Cloud9-APIs/Window" 
}

local ASSESTS = {
    ["WINDOWS"] = "Cloud9-APIs/unearth/assests/unearth_windows"
}

local w, h = term.getSize()
local line = ""
for i = 1, w do
    line = line.."-"
end

-- # Functions for Loading & Unloading APIs into/from Environment:
local function LOAD_APIS(doPrint)
    term.setTextColor(colors.lime)
    for ID, path in pairs(APIS) do
        if not os.loadAPI(path) then
            error("\n[API: "..path.."]\nStatus: <Error>\n"..line, 2)
        end
        if doPrint then
            print("[API: "..path.."]\nStatus: <Loaded>\n"..line)
            sleep(0.05)
        end
    end
end

local function LOAD_ASSESTS(doPrint)
    term.setTextColor(colors.lime)
    for ID, path in pairs(ASSESTS) do
        if not os.loadAPI(path) then
            error("\n[ASSEST: "..path.."]\nStatus: <Error>\n"..line, 2)
        end
        if doPrint then
            print("[API: "..path.."]\nStatus: <Loaded>\n"..line)
            sleep(0.05)
        end
    end
end

local function UNLOAD_APIS(doPrint)
    term.setTextColor(colors.lime)
    for ID, path in pairs(APIS) do
        os.unloadAPI(path)
        if doPrint then
            print("[API: "..path.."]\nStatus: <Unloaded>\n"..line)
            sleep(0.05)
        end
    end
end

local function UNLOAD_ASSESTS(doPrint)
    term.setTextColor(colors.lime)
    for ID, path in pairs(ASSESTS) do
        os.unloadAPI(path)
        if doPrint then
            print("[API: "..path.."]\nStatus: <Unloaded>\n"..line)
            sleep(0.05)
        end
    end
end

if not C9 then
    LOAD_APIS(true)
end

-- # Local Program Variables:
local environment = Environment.new()
unearth_term = Screen.new()
_G.unearth.unearth_term = unearth_term

local terminate = false
local editting = false
local open_menu = false

-- # Screen Modules:
local main_screen = unearth_term:add(1, 2, w, h - 2, colors.black, colors.gray, 1)
local edit_screen = unearth_term:add(1, 2, w, h - 2, colors.black, colors.white, 3, true)
local console_screen = unearth_term:add(1, 2, w - 1, h - 2, colors.lime, colors.black, 1, true)
local bottom_bar = unearth_term:add(1, h, w, 1, colors.black, colors.lightGray, 2)
local top_bar = unearth_term:add(1, 1, w, 1, colors.white, colors.blue, 2)

-- # Local Screen Tracers:
local current_screen = main_screen
local previous_screen = current_screen

-- # Load Window Assests After Screen Definitions:
LOAD_ASSESTS(true)

-- # Main Button Modules:
local button_close = Button.new({
    ["text"] = string.char(215),
    ["xPos"] = w - 2,
    ["yPos"] = 1,
    ["xPad"] = 1,
    ["foreground"] = colors.white,
    ["background"] = colors.red,
    ["bFlash"] = colors.gray,
    ["screen"] = top_bar
})

local button_file = Button.new({
    ["text"] = "[File]",
    ["xPos"] = 1,
    ["yPos"] = 1,
    ["foreground"] = colors.white,
    ["background"] = colors.blue,
    ["tFlash"] = colors.lightGray,
    ["screen"] = top_bar
})

button_turtle = Button.new({
    ["text"] = "[Turtle]",
    ["xPos"] = 8,
    ["yPos"] = 1,
    ["foreground"] = colors.white,
    ["background"] = colors.blue,
    ["tFlash"] = colors.lightGray,
    ["screen"] = top_bar
})

local button_console = Button.new({
    ["text"] = "[Console]",
    ["xPos"] = 1,
    ["yPos"] = 1,
    ["foreground"] = colors.black,
    ["background"] = colors.lightGray,
    ["tFlash"] = colors.gray,
    ["screen"] = bottom_bar
})

-- # Local Program Functions:
local function wrap(var)
    if var == nil then
        return "False"
    elseif var == true then
        return "True"
    elseif var == false then
        return "False"
    elseif type(var) == "number" then
        return "Number"
    elseif type(var) == "string" then
        return "String" 
    end
end

local function color(var)
    if var == true then
        return colors.green
    elseif var == false then
        return colors.red
    else
        return colors.purple
    end
end

local function log(msg, msg_type)
    local line = ""
    for i = 1, console_screen.width do
        line = line.."-"
    end

    if not msg_type then msg_type = "INFO" end

    if msg_type == "INFO" then
        local message = {
            [1] = "[",
            [2] = "INFO",
            [3] = "] (",
            [4] = "Day: ",
            [5] = os.day(),
            [6] = ") [",
            [7] = textutils.formatTime(os.time(), false),
            [8] = "] ",
            [9] = msg.."\n",
            [10] = line
        }
    
        local message_foreground = {
            [1] = colors.white,
            [2] = colors.green,
            [3] = colors.white,
            [4] = colors.lime,
            [5] = colors.red,
            [6] = colors.white,
            [7] = colors.red,
            [8] = colors.white,
            [9] = colors.lime,
            [10] = colors.gray
        }
    
        Text.display({
            ["text"] = message,
            ["startX"] = 1,
            ["startY"] = console_screen.curY,
            ["foreground"] = message_foreground,
            ["background"] = colors.black,
            ["buffer"] = true,
            ["wrapper"] = "new line",
            ["screen"] = console_screen
        })
    end

    -- # Update Screen:
    console_screen.curY = console_screen.curY + 1
end

-- # Load Appdata & Profiles from Assests:
local file_appdata = fs.open("Cloud9-APIs/unearth/assests/appdata", "r")
local file_profiles = fs.open("Cloud9-APIs/unearth/assests/profiles", "r")

-- # Local Variables from Assests:
local appdata = textutils.unserialize(file_appdata.readAll())
local profiles = textutils.unserialize(file_profiles.readAll())
local loaded_profile = profiles[appdata.last_profile]

-- * Startup Definitions:
-- # Parent Clearing:
unearth_term:setBackgroundColor(colors.black)
unearth_term:setTextColor(colors.white)
unearth_term:clear()

-- # Main Screen Clearing:
unearth_term.clear(main_screen)

-- # Top Bar Clearing:
unearth_term.clear(top_bar)

-- # Bottom Bar Clearing:
unearth_term.clear(bottom_bar)

-- # Main Button Displays:
button_close:display()
button_file:display()
button_turtle:display()
button_console:display()

-- # Push Message to Console of Success:
log("Successfully loaded all APIs", "INFO")

-- # Log Successful Assests Boot:
log("Successfully loaded assests", "INFO")

-- # Log Profile Loaded:
log("Loaded: ['"..loaded_profile.name.."'], for profile")

-- # Push Successful Protocol to Console:
log("Successfully pulled turtle information")

-- # Push Profile Update to Event Queue:
os.queueEvent("UNEARTH_PROFILE_UPDATE")

-- # Main Program Modules:
--[[
    >>>
        MAIN
        SCREEN
    <<<
]]

function MODULE_MAIN_SCREEN()
    -- # Event Handler:
    while true do
        local event = os.pullEvent()
        if event == "UNEARTH_PROFILE_UPDATE" or event == "UPDATE_PROFILE_VARIABLES" or event == "turtle_update" then
            unearth_term.clear(main_screen)

            -- # Display Current Profile:
            Text.display({
                ["text"] = {
                    [1] = "Current Profile",
                    [2] = ": ",
                    [3] = "<",
                    [4] = loaded_profile.name,
                    [5] = ">"
                },
                ["startX"] = 1,
                ["startY"] = 1,
                ["foreground"] = {
                    [1] = colors.black,
                    [2] = colors.black,
                    [3] = colors.red,
                    [4] = colors.lime,
                    [5] = colors.red
                },
                ["background"] = colors.gray,
                ["wrapper"] = "concat",
                ["screen"] = main_screen
            })

            -- # Draw Static Information:
            local line = ""
            for i = 1, main_screen.width do
                line = line..string.char(183)
            end

            unearth_term.setTextColor(main_screen, colors.white)
            for i = 3, main_screen.height do
                unearth_term.setCursorPos(main_screen, 26, i)
                unearth_term.write(main_screen, string.char(183))
            end

            Text.display({
                ["text"] = line,
                ["startX"] = 1,
                ["startY"] = 2,
                ["foreground"] = colors.white,
                ["background"] = colors.gray,
                ["screen"] = main_screen
            })

            -- # Display Profile Variables:
            Text.display({
                ["text"] = {
                    [1] = "Direction: ",
                    [2] = loaded_profile.direction.."\n",
                    [3] = "Width: ",
                    [4] = loaded_profile.width.."\n",
                    [5] = "Height: ",
                    [6] = loaded_profile.height.."\n",
                    [7] = "Length: ",
                    [8] = loaded_profile.length.."\n",
                    [9] = "Place Torch: ",
                    [10] = wrap(loaded_profile.place_torch).."\n",
                    [11] = "Torch Distance: ",
                    [12] = loaded_profile.torch_distance.."\n",
                    [13] = "Ender Chest Dump: ",
                    [14] = wrap(loaded_profile.ender_chest_dump).."\n",
                    [15] = "Ender Chest Fuel: ",
                    [16] = wrap(loaded_profile.ender_chest_fuel).."\n",
                    [17] = "Ender Chest Torch: ",
                    [18] = wrap(loaded_profile.ender_chest_torch).."\n"
                },
                ["startX"] = 1,
                ["startY"] = 3,
                ["foreground"] = {
                    [1] = colors.black,
                    [2] = colors.blue,
                    [3] = colors.black,
                    [4] = colors.orange,
                    [5] = colors.black,
                    [6] = colors.orange,
                    [7] = colors.black,
                    [8] = colors.orange,
                    [9] = colors.black,
                    [10] = color(loaded_profile.place_torch),
                    [11] = colors.black,
                    [12] = colors.orange,
                    [13] = colors.black,
                    [14] = color(loaded_profile.ender_chest_dump),
                    [15] = colors.black,
                    [16] = color(loaded_profile.ender_chest_fuel),
                    [17] = colors.black,
                    [18] = color(loaded_profile.ender_chest_torch),
                },
                ["background"] = colors.gray,
                ["wrapper"] = "new line",
                ["screen"] = main_screen
            })

            -- # Display Current Fuel Levels:
            Text.display({
                ["text"] = {
                    [1] = "Fuel Limit:\n",
                    [2] = turtle.getFuelLimit().."\n\n",
                    [3] = "Fuel Level:\n",
                    [4] = turtle.getFuelLevel().."\n\n",
                    [5] = "Unearthing:\n",
                    [6] = "[WIP]"
                },
                ["startX"] = 28,
                ["startY"] = 3,
                ["foreground"] = {
                    [1] = colors.black,
                    [2] = colors.green,
                    [3] = colors.black,
                    [4] = colors.green,
                    [5] = colors.black,
                    [6] = colors.red
                },
                ["background"] = colors.gray,
                ["wrapper"] = "new line",
                ["screen"] = main_screen
            })
        end
    end
end

--[[
    >>>
        CALCULATOR
        MODULE
    <<<
]]

local function MODULE_CALCULATOR()
    -- # Event Handler:
    while true do
        local event, p1, p2, p3 = os.pullEvent()

        if event == "UNEARTH_OPEN_NUMBERPAD" then
            unearth_windows.calc_window:run(unearth_windows.display_numberpad)
        end
        unearth_windows.calc_window:move(event, p2, p3, 
            function(startX, startY, endX, endY) 
                if startY > 1 and endY < h then
                    return true 
                else
                    return false
                end
            end)
    end
end

--[[
    >>>
        EDIT PROFILE
        MODULE
    <<<
]]

function MODULE_EDIT_PROFILE()
    -- # Local Module Buttons:
    local button_done_editting = Button.new({
        ["text"] = "Done",
        ["xPos"] = 33,
        ["yPos"] = 6,
        ["xPad"] = 1,
        ["yPad"] = 1,
        ["foreground"] = colors.white,
        ["background"] = colors.green,
        ["bFlash"] = colors.gray,
        ["screen"] = edit_screen
    })

    local button_direction = Button.new({
        ["text"] = "[Direction]",
        ["xPos"] = 1,
        ["yPos"] = 3,
        ["foreground"] = colors.black,
        ["background"] = colors.white,
        ["tFlash"] = colors.lightGray,
        ["screen"] = edit_screen
    })

    local button_width = Button.new({
        ["text"] = "[Width]",
        ["xPos"] = 1,
        ["yPos"] = 4,
        ["foreground"] = colors.black,
        ["background"] = colors.white,
        ["tFlash"] = colors.lightGray,
        ["screen"] = edit_screen
    })

    local button_height = Button.new({
        ["text"] = "[Height]",
        ["xPos"] = 1,
        ["yPos"] = 5,
        ["foreground"] = colors.black,
        ["background"] = colors.white,
        ["tFlash"] = colors.lightGray,
        ["screen"] = edit_screen
    })

    local button_length = Button.new({
        ["text"] = "[Length]",
        ["xPos"] = 1,
        ["yPos"] = 6,
        ["foreground"] = colors.black,
        ["background"] = colors.white,
        ["tFlash"] = colors.lightGray,
        ["screen"] = edit_screen
    })

    local button_place_torch = Button.new({
        ["text"] = "[Place Torch]",
        ["xPos"] = 1,
        ["yPos"] = 7,
        ["foreground"] = colors.black,
        ["background"] = colors.white,
        ["tFlash"] = colors.lightGray,
        ["screen"] = edit_screen
    })

    local button_torch_distance = Button.new({
        ["text"] = "[Torch Distance]",
        ["xPos"] = 1,
        ["yPos"] = 8,
        ["foreground"] = colors.black,
        ["background"] = colors.white,
        ["tFlash"] = colors.lightGray,
        ["screen"] = edit_screen
    })

    local button_ender_chest_dump = Button.new({
        ["text"] = "[Ender: Dump]",
        ["xPos"] = 1,
        ["yPos"] = 9,
        ["foreground"] = colors.black,
        ["background"] = colors.white,
        ["tFlash"] = colors.lightGray,
        ["screen"] = edit_screen
    })

    local button_ender_chest_fuel = Button.new({
        ["text"] = "[Ender: Fuel]",
        ["xPos"] = 1,
        ["yPos"] = 10,
        ["foreground"] = colors.black,
        ["background"] = colors.white,
        ["tFlash"] = colors.lightGray,
        ["screen"] = edit_screen
    })

    local button_ender_chest_torch = Button.new({
        ["text"] = "[Ender: Torch]",
        ["xPos"] = 1,
        ["yPos"] = 11,
        ["foreground"] = colors.black,
        ["background"] = colors.white,
        ["tFlash"] = colors.lightGray,
        ["screen"] = edit_screen
    })

    -- # Local Module Variables:
    local lock = "" 
    local prev_file = button_file.foreground
    local prev_turtle = button_turtle.foreground
    local prev_console = button_console.foreground

    -- # Event Handler:
    while true do
        local event, p1, p2, p3 = os.pullEvent()

        if event == "START_EDITTING" and editting then
            -- # Gray Out Inapplicable Buttons:
            button_file.foreground = colors.gray
            button_file:display()

            button_turtle.foreground = colors.gray
            button_turtle:display()

            button_console.foreground = colors.gray
            button_console:display()

            -- # Display Current Profile:
            Text.display({
                ["text"] = {
                    [1] = "Current Profile",
                    [2] = ": ",
                    [3] = "<",
                    [4] = loaded_profile.name,
                    [5] = ">"
                },
                ["startX"] = 1,
                ["startY"] = 1,
                ["foreground"] = {
                    [1] = colors.black,
                    [2] = colors.black,
                    [3] = colors.red,
                    [4] = colors.lime,
                    [5] = colors.red
                },
                ["background"] = colors.white,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })

            -- # Draw Static Information:
            local line = ""
            for i = 1, edit_screen.width do
                line = line..string.char(183)
            end

            unearth_term.setTextColor(edit_screen, colors.black)
            for i = 3, edit_screen.height do
                unearth_term.setCursorPos(edit_screen, 31, i)
                unearth_term.write(edit_screen, string.char(183))
            end

            Text.display({
                ["text"] = line,
                ["startX"] = 1,
                ["startY"] = 2,
                ["foreground"] = colors.black,
                ["background"] = colors.white,
                ["screen"] = edit_screen
            })

            -- # Display Buttons:
            button_done_editting:display()
            button_direction:display()
            button_width:display()
            button_height:display()
            button_length:display()
            button_place_torch:display()
            button_torch_distance:display()
            button_ender_chest_dump:display()
            button_ender_chest_fuel:display()
            button_ender_chest_torch:display()
        elseif button_direction:call(event, p2, p3) and editting then
            -- # Change Variable:
            if loaded_profile.direction == "Horizontal" then
                loaded_profile.direction = "Vertical"
            else
                loaded_profile.direction = "Horizontal"
            end

            -- # Queue Update Event:
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
        elseif button_width:call(event, p2, p3) and editting and lock == "" then
            -- # Load Numberpad Window:
            os.queueEvent("UNEARTH_OPEN_NUMBERPAD", "width")
            
            -- # Locking Mechanism to Avoid Multiple Numberpad Windows:
            lock = "width"
        elseif event == "UNEARTH_FINISHED_CALCULATING" and p1 == "width" and editting and lock == "width" then
            if type(p2) == "number" then
                loaded_profile.width = tonumber(p2)
            elseif p2 == "" then
                loaded_profile.width = loaded_profile.width
            else
                loaded_profile.width = p2
            end 

            -- # Queue Update Event & Lock:
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
            lock = ""
        elseif button_height:call(event, p2, p3) and editting and lock == "" then
            -- # Load Numberpad Window:
            os.queueEvent("UNEARTH_OPEN_NUMBERPAD", "height")

            -- # Locking Mechanism to Avoid Multiple Numberpad Windows:
            lock = "height"
        elseif event == "UNEARTH_FINISHED_CALCULATING" and p1 == "height" and editting and lock == "height" then
            if type(p2) == "number" then
                loaded_profile.height = tonumber(p2)
            elseif p2 == "" then
                loaded_profile.height = loaded_profile.height
            else
                loaded_profile.height = p2
            end

            -- # Queue Update Event & Lock:
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
            lock = ""
        elseif button_length:call(event, p2, p3) and editting and lock == "" then
            -- # Load Numberpad Window:
            os.queueEvent("UNEARTH_OPEN_NUMBERPAD", "length")

            -- # Locking Mechanism to Avoid Multiple Numberpad Windows:
            lock = "length"
        elseif event == "UNEARTH_FINISHED_CALCULATING" and p1 == "length" and editting and lock == "length" then
            if type(p2) == "number" then
                loaded_profile.length = tonumber(p2)
            elseif p2 == "" then
                loaded_profile.length = loaded_profile.length
            else
                loaded_profile.length = p2
            end

            -- # Queue Update Event & Lock:
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
            lock = ""
        elseif button_place_torch:call(event, p2, p3) and editting then
            -- # Change Variable:
            if loaded_profile.place_torch == true then
                loaded_profile.place_torch = false
            else
                loaded_profile.place_torch = true
            end

            -- # Queue Update Event:
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
        elseif button_torch_distance:call(event, p2, p3) and editting and lock == "" then
            -- # Load Numberpad Window:
            os.queueEvent("UNEARTH_OPEN_NUMBERPAD", "torch_distance")

            -- # Locking Mechanism to Avoid Multiple Numberpad Windows:
            lock = "torch_distance"
        elseif event == "UNEARTH_FINISHED_CALCULATING" and p1 == "torch_distance" and editting and lock == "torch_distance" then
            if type(p2) == "number" then
                loaded_profile.torch_distance = tonumber(p2)
            elseif p2 == "" then
                loaded_profile.torch_distance = loaded_profile.torch_distance
            else
                loaded_profile.torch_distance = p2
            end

            -- # Queue Update Event & Lock:
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
            lock = ""
        elseif button_ender_chest_dump:call(event, p2, p3) and editting then
            -- # Change Variable:
            if loaded_profile.ender_chest_dump == true then
                loaded_profile.ender_chest_dump = false
            else
                loaded_profile.ender_chest_dump = true
            end

            -- # Queue Update Event:
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
        elseif button_ender_chest_fuel:call(event, p2, p3) and editting then
            -- # Change Variable:
            if loaded_profile.ender_chest_fuel == true then
                loaded_profile.ender_chest_fuel = false
            else
                loaded_profile.ender_chest_fuel = true
            end

            -- # Queue Update Event:
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
        elseif button_ender_chest_torch:call(event, p2, p3) and editting then
            -- # Change Variable:
            if loaded_profile.ender_chest_torch == true then
                loaded_profile.ender_chest_torch = false
            else
                loaded_profile.ender_chest_torch = true
            end

            -- # Queue Update Event:
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
        elseif event == "UPDATE_PROFILE_VARIABLES" and editting then
            -- # Display Profile Variables:
            unearth_term.clearLine(edit_screen, false, false, 3)
            Text.display({
                ["text"] = loaded_profile.direction,
                ["foreground"] = colors.blue,
                ["background"] = colors.white,
                ["startX"] = 30 - string.len(loaded_profile.direction),
                ["startY"] = 3,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })
            unearth_term.clearLine(edit_screen, false, false, 4)
            Text.display({
                ["text"] = tostring(loaded_profile.width),
                ["foreground"] = colors.orange,
                ["background"] = colors.white,
                ["startX"] = 30 - string.len(loaded_profile.width),
                ["startY"] = 4,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })
            unearth_term.clearLine(edit_screen, false, false, 5)
            Text.display({
                ["text"] = tostring(loaded_profile.height),
                ["foreground"] = colors.orange,
                ["background"] = colors.white,
                ["startX"] = 30 - string.len(loaded_profile.height),
                ["startY"] = 5,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })
            unearth_term.clearLine(edit_screen, false, false, 6)
            Text.display({
                ["text"] = tostring(loaded_profile.length),
                ["foreground"] = colors.orange,
                ["background"] = colors.white,
                ["startX"] = 30 - string.len(loaded_profile.length),
                ["startY"] = 6,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })
            unearth_term.clearLine(edit_screen, false, false, 7)
            Text.display({
                ["text"] = wrap(loaded_profile.place_torch),
                ["foreground"] = color(loaded_profile.place_torch),
                ["background"] = colors.white,
                ["startX"] = 30 - string.len(wrap(loaded_profile.place_torch)),
                ["startY"] = 7,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })
            unearth_term.clearLine(edit_screen, false, false, 8)
            Text.display({
                ["text"] = tostring(loaded_profile.torch_distance),
                ["foreground"] = colors.orange,
                ["background"] = colors.white,
                ["startX"] = 30 - string.len(loaded_profile.torch_distance),
                ["startY"] = 8,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })
            unearth_term.clearLine(edit_screen, false, false, 9)
            Text.display({
                ["text"] = wrap(loaded_profile.ender_chest_dump),
                ["foreground"] = color(loaded_profile.ender_chest_dump),
                ["background"] = colors.white,
                ["startX"] = 30 - string.len(wrap(loaded_profile.ender_chest_dump)),
                ["startY"] = 9,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })
            unearth_term.clearLine(edit_screen, false, false, 10)
            Text.display({
                ["text"] = wrap(loaded_profile.ender_chest_fuel),
                ["foreground"] = color(loaded_profile.ender_chest_fuel),
                ["background"] = colors.white,
                ["startX"] = 30 - string.len(wrap(loaded_profile.ender_chest_fuel)),
                ["startY"] = 10,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })
            unearth_term.clearLine(edit_screen, false, false, 11)
            Text.display({
                ["text"] = wrap(loaded_profile.ender_chest_torch),
                ["foreground"] = color(loaded_profile.ender_chest_torch),
                ["background"] = colors.white,
                ["startX"] = 30 - string.len(wrap(loaded_profile.ender_chest_torch)),
                ["startY"] = 11,
                ["wrapper"] = "concat",
                ["screen"] = edit_screen
            })
            unearth_term.setTextColor(edit_screen, colors.black)
            for i = 3, edit_screen.height do
                unearth_term.setCursorPos(edit_screen, 31, i)
                unearth_term.write(edit_screen, string.char(183))
            end
        elseif button_done_editting:call(event, p2, p3) and editting then
            -- # Update Grayed Out Buttons:
            button_file.foreground = prev_file
            button_file:display()

            button_turtle.foreground = prev_turtle
            button_turtle:display()

            button_console.foreground = prev_console
            button_console:display()

            -- # Update Screens:
            unearth_term.visible(edit_screen, false)
            unearth_term.visible(main_screen, true)
            unearth_term:refresh(true)

            -- # Update Screen Tracers:
            current_screen = main_screen
            previous_screen = edit_screen

            -- # Update Handlers:
            editting = false
        end
    end    
end

--[[
    >>>
        FILE
        SELECTION
    <<<
]]

function MODULE_FILE_SELECTION()
    -- # Local Module Variables:
    local isVisible = false
    local menu_file = unearth_term:add(1, 2, 15, 5, colors.black, colors.lightGray, 3, true)

    -- # Local Module Buttons:
    local button_load_profile = Button.new({
        ["text"] = "> Load Profile ",
        ["xPos"] = 1,
        ["yPos"] = 1,
        ["foreground"] = colors.black,
        ["background"] = colors.lightGray,
        ["bFlash"] = colors.gray,
        ["screen"] = menu_file
    })

    local button_save_profile = Button.new({
        ["text"] = "> Save Profile ",
        ["xPos"] = 1,
        ["yPos"] = 2,
        ["foreground"] = colors.black,
        ["background"] = colors.lightGray,
        ["bFlash"] = colors.gray,
        ["screen"] = menu_file
    })

    local button_edit_profile = Button.new({
        ["text"] = "> Edit Profile ",
        ["xPos"] = 1,
        ["yPos"] = 3,
        ["foreground"] = colors.black,
        ["background"] = colors.lightGray,
        ["bFlash"] = colors.gray,
        ["screen"] = menu_file
    })

    local button_reboot = Button.new({
        ["text"] = "> Close Program",
        ["xPos"] = 1,
        ["yPos"] = 5,
        ["foreground"] = colors.black,
        ["background"] = colors.lightGray,
        ["bFlash"] = colors.gray,
        ["screen"] = menu_file
    })

    -- # Event Handler:
    while true do
        local event, p1, p2, p3 = os.pullEvent()
        if editting then
            -- > Skip...
        elseif button_file:call(event, p2, p3) and not isVisible then
            -- $ Update Event Variables:
            isVisible = true
            open_menu = true
            
            -- $ Make Menu Screen Visible:
            unearth_term.visible(menu_file, true)
            unearth_term:refresh(true)

            -- $ Make Menu Buttons Visible:
            button_load_profile:display()
            button_save_profile:display()
            button_edit_profile:display()
            button_reboot:display()

            -- $ Display Seperator Bar:
            for i = 1, menu_file.width do
                unearth_term.setCursorPos(menu_file, i, 4)
                unearth_term.write(menu_file, "-")
            end
        elseif button_load_profile:call(event, p2, p3) and isVisible then
            -- $ Load Profile Module Here...
        elseif button_save_profile:call(event, p2, p3) and isVisible then
            -- $ Save Profile Module Here...
        elseif button_edit_profile:call(event, p2, p3) and isVisible then
            -- # Update Screens:
            unearth_term.visible(current_screen, false)
            unearth_term.visible(menu_file, false)
            unearth_term.visible(edit_screen, true)
            unearth_term:refresh(true)

            -- # Update Screen Tracers:
            previous_screen = current_screen
            current_screen = edit_screen

            -- # Update Handlers:
            isVisible = false
            open_menu = false
            editting = true

            -- # Push Events to Module:
            os.queueEvent("START_EDITTING")
            os.queueEvent("UPDATE_PROFILE_VARIABLES")
        elseif button_reboot:call(event, p2, p3) and isVisible then
            terminate = true
        elseif event == "mouse_click" and isVisible then 
            if p2 < menu_file.startX or p3 < menu_file.startY or p2 > menu_file.endX or p3 > menu_file.endY then
                isVisible = false
                unearth_term.visible(menu_file, false)
                unearth_term:refresh(true)
            end
        end
    end
end

--[[
    >>>
        TURTLE
        SELECTION
    <<<
]]

function MODULE_TURTLE_SELECTION()
    -- # Local Module Variables:
    local isVisible = false
    local menu_turtle = unearth_term:add(8, 2, 15, 5, colors.black, colors.lightGray, 3, true)

    -- # Local Module Buttons:
    local button_start = Button.new({
        ["text"] = "> Start Digging",
        ["xPos"] = 1,
        ["yPos"] = 1,
        ["foreground"] = colors.black,
        ["background"] = colors.lightGray,
        ["bFlash"] = colors.gray,
        ["screen"] = menu_turtle
    })

    local button_pause = Button.new({
        ["text"] = "> Pause Digging",
        ["xPos"] = 1,
        ["yPos"] = 2,
        ["foreground"] = colors.black,
        ["background"] = colors.lightGray,
        ["bFlash"] = colors.gray,
        ["screen"] = menu_turtle
    })

    local button_stop = Button.new({
        ["text"] = "> Stop Digging ",
        ["xPos"] = 1,
        ["yPos"] = 3,
        ["foreground"] = colors.black,
        ["background"] = colors.lightGray,
        ["bFlash"] = colors.gray,
        ["screen"] = menu_turtle
    })

    local button_control = Button.new({
        ["text"] = "> Take Control ",
        ["xPos"] = 1,
        ["yPos"] = 5,
        ["foreground"] = colors.black,
        ["background"] = colors.lightGray,
        ["bFlash"] = colors.gray,
        ["screen"] = menu_turtle
    })

    -- # Event Handler:
    while true do
        local event, p1, p2, p3 = os.pullEvent()
        if editting then
            -- > Skip...
        elseif button_turtle:call(event, p2, p3) and not isVisible then
            -- $ Update Event Variables:
            isVisible = true
            open_menu = true
            
            -- $ Make Menu Screen Visible:
            unearth_term.visible(menu_turtle, true)
            unearth_term:refresh(true)

            -- $ Make Menu Buttons Visible:
            button_start:display()
            button_pause:display()
            button_stop:display()
            button_control:display()

            -- $ Display Seperator Bar:
            for i = 1, menu_turtle.width do
                unearth_term.setCursorPos(menu_turtle, i, 4)
                unearth_term.write(menu_turtle, "-")
            end
        elseif button_start:call(event, p2, p3) and isVisible then
            -- $ Start Digging if not Already Started...
        elseif button_pause:call(event, p2, p3) and isVisible then
            -- $ Pause Digging...
        elseif button_stop:call(event, p2, p3) and isVisible then
            -- $ Stop Digging...
        elseif button_control:call(event, p2, p3) and isVisible then
            -- $ Boot Remote Control Turtle Program...
        elseif event == "mouse_click" and isVisible then 
            if p2 < menu_turtle.startX or p3 < menu_turtle.startY or p2 > menu_turtle.endX or p3 > menu_turtle.endY then
                isVisible = false
                open_menu = false
                unearth_term.visible(menu_turtle, false)
                unearth_term:refresh(true)
            end
        end
    end
end

--[[
    >>>
        CONSOLE
        DISPLAY
    <<<
]]

function MODULE_CONSOLE()
    -- # Local Module Variables:
    local isVisible = false
    local scrollbar = unearth_term:add(w, 2, 1, h - 2, colors.white, colors.black, 2, true)

    -- # Local Scrollbar Arrow Buttons:
    local up_arrow = Button.new({
        ["text"] = string.char(24),
        ["xPos"] = 1,
        ["yPos"] = 1,
        ["foreground"] = colors.lightGray,
        ["background"] = colors.black,
        ["tFlash"] = colors.gray,
        ["screen"] = scrollbar
    })
    
    local down_arrow = Button.new({
        ["text"] = string.char(25),
        ["xPos"] = 1,
        ["yPos"] = h - 2,
        ["foreground"] = colors.lightGray,
        ["background"] = colors.black,
        ["tFlash"] = colors.gray,
        ["screen"] = scrollbar
    })

    local scroller = Button.new({
        ["text"] = "+",
        ["xPos"] = 1,
        ["yPos"] = 2,
        ["foreground"] = colors.lightGray,
        ["background"] = colors.black,
        ["tFlash"] = colors.gray,
        ["screen"] = scrollbar,
    })

    -- # Draw Vertical Scrolling Bar:
    for i = 2, h - 3 do
        unearth_term.setCursorPos(scrollbar, 1, i)
        unearth_term.write(scrollbar, "|")
    end

    -- # Event Handler:
    while true do
        local event, p1, p2, p3 = os.pullEvent()

        -- # Slider Checks:
        local move, _, y = scroller:move(event, p2, p3, "x", function()
            if p3 >= 3 and p3 <= h - 2 then
                return true
            else
                return false
            end
        end)
        if move and not editting then
            if y < console_screen.curY then
                unearth_term.scroll(console_screen, -y)
            end  
        end

        if editting then
            -- > Skip...
        elseif button_console:call(event, p2, p3) then
            if not isVisible then
                -- $ Update Visibility of Console:
                isVisible = true
    
                -- $ Make Screen Adjustments:
                unearth_term.visible(current_screen, false)
                unearth_term.visible(console_screen, true)
                unearth_term.visible(scrollbar, true)
                unearth_term:refresh(true)

                -- $ Update Screen Tracers:
                previous_screen = current_screen
                current_screen = console_screen

                -- $ Make Scollbar Buttons Visible:
                up_arrow:display()
                down_arrow:display()
                scroller:display()
            else
                -- $ Update Visibility of Console:
                isVisible = false

                -- $ Make Screen Adjustments:
                unearth_term.visible(previous_screen, true)
                unearth_term.visible(console_screen, false)
                unearth_term.visible(scrollbar, false)
                unearth_term:refresh(true)

                -- $ Update Screen Tracers:
                current_screen = previous_screen
                previous_screen = console_screen
            end
        elseif down_arrow:call(event, p2, p3) and isVisible then
            unearth_term.scroll(console_screen, 1)
        elseif up_arrow:call(event, p2, p3) and isVisible then
            unearth_term.scroll(console_screen, -1)
        elseif isVisible and current_screen ~= console_screen then
            -- $ Update Visibility of Console:
            isVisible = false
        end
    end
end

--[[
    >>>
        PROGRAM
        CLOCK
    <<<
]]

function MODULE_CLOCK()
    while true do
        sleep(0.05)
        local time = textutils.formatTime(os.time(), false)
    
        -- # Print out Time:
        unearth_term.setTextColor(bottom_bar, colors.black)
        unearth_term.setCursorPos(bottom_bar, w - time:len() + 1, 1)
        unearth_term.write(bottom_bar, time)
    
        -- # Check for Extended String:
        if time:len() == 7 then
            unearth_term.setCursorPos(bottom_bar, w - time:len(), 1)
            unearth_term.write(bottom_bar, " ")
        end
    end
end

--[[
    >>>
        PROGRAM
        TERMINATIONS
    <<<
]]

function MODULE_TERMINATION()
    while true do
        local e1, e2, e3, e4 = os.pullEvent()
        if e1 == "key" and e2 == keys["end"] then
            terminate = true
        end

        if button_close:call(e1, e3, e4) then
            terminate = true
        end

        if terminate then
            environment:stop()
            break
        end
    end
end

-- # Adding Modules:
environment:add("MAIN_SCREEN", MODULE_MAIN_SCREEN)
environment:add("EDIT_PROFILE", MODULE_EDIT_PROFILE)
environment:add("FILE_SELECTION", MODULE_FILE_SELECTION)
environment:add("TURTLE_SELECTION", MODULE_TURTLE_SELECTION)
environment:add("CALCULATOR", MODULE_CALCULATOR)
environment:add("NUMBERPAD", unearth_windows.MODULE_NUMBERPAD)
environment:add("CONSOLE", MODULE_CONSOLE)
environment:add("CLOCK", MODULE_CLOCK)
environment:add("TERMINATION", MODULE_TERMINATION)

-- # Run Environment:
environment:run()

-- # Unloading the APIs if Errored or Program Ended:
if not C9 then
    if environment.errored then
        UNLOAD_APIS(false)
        UNLOAD_ASSESTS(false)
    else
        UNLOAD_APIS(true)
        UNLOAD_ASSESTS(true)
    end
else
    sleep(1)
    _G.term.clear()
    _G.term.setCursorPos(1, 1)
end

-- End of Document